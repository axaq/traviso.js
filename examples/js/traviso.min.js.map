{"version":3,"file":"traviso.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../src/pathFinding/GridNode.ts","../../src/pathFinding/BinaryHeap.ts","../../src/pathFinding/PathFinding.ts","../../src/utils/calculations.ts","../../src/utils/constants.ts","../../src/utils/trace.ts","../../src/utils/map.ts","../../src/utils/easing.ts","../../src/map/MoveEngine.ts","../../src/map/ObjectView.ts","../../src/map/TileView.ts","../../src/map/EngineView.ts","../../src/utils/hello.ts","../../src/version.ts","../../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { TColumnRowPair } from '../utils/map';\n\nexport class GridNode {\n    public x: number;\n    public y: number;\n    public weight: number;\n    public staticWeight: number;\n    public mapPos: TColumnRowPair;\n    // calculation params\n    public closed: boolean;\n    public parent: GridNode;\n    public visited: boolean;\n    public h: number;\n    public g: number;\n    public f: number;\n\n    constructor(c: number, r: number, weight: number) {\n        this.x = c;\n        this.y = r;\n        this.weight = weight;\n        this.mapPos = { c, r };\n    }\n\n    public toString(): string {\n        return '[' + String(this.x) + ' ' + String(this.y) + ']';\n    }\n    public getCost(fromNeighbor: GridNode): number {\n        // Take diagonal weight into consideration.\n        if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {\n            return this.weight * 1.41421;\n        }\n        return this.weight;\n    }\n\n    public isWall(): boolean {\n        return this.weight === 0;\n    }\n}\n","export class BinaryHeap {\n    private content: unknown[];\n    private scoreFunction: (element: unknown) => number;\n\n    constructor(scoreFunction: (element: unknown) => number) {\n        this.content = [];\n        this.scoreFunction = scoreFunction;\n    }\n\n    public push(element: unknown): void {\n        // Add the new element to the end of the array.\n        this.content.push(element);\n\n        // Allow it to sink down.\n        this.sinkDown(this.content.length - 1);\n    }\n    public pop(): unknown {\n        // Store the first element so we can return it later.\n        const result = this.content[0];\n        // Get the element at the end of the array.\n        const end = this.content.pop();\n        // If there are any elements left, put the end element at the\n        // start, and let it bubble up.\n        if (this.content.length > 0) {\n            this.content[0] = end;\n            this.bubbleUp(0);\n        }\n        return result;\n    }\n\n    // private remove(node: unknown) {\n    //     const i = this.content.indexOf(node);\n\n    //     // When it is found, the process seen in 'pop' is repeated\n    //     // to fill up the hole.\n    //     const end = this.content.pop();\n\n    //     if (i !== this.content.length - 1) {\n    //         this.content[i] = end;\n\n    //         if (this.scoreFunction(end) < this.scoreFunction(node)) {\n    //             this.sinkDown(i);\n    //         }\n    //         else {\n    //             this.bubbleUp(i);\n    //         }\n    //     }\n    // }\n    public size(): number {\n        return this.content.length;\n    }\n    public rescoreElement(node: unknown): void {\n        this.sinkDown(this.content.indexOf(node));\n    }\n    private sinkDown(n: number): void {\n        // Fetch the element that has to be sunk.\n        const element = this.content[n];\n\n        // When at 0, an element can not sink any further.\n        while (n > 0) {\n            // Compute the parent element's index, and fetch it.\n            const parentN = ((n + 1) >> 1) - 1,\n                parent = this.content[parentN];\n            // Swap the elements if the parent is greater.\n            if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n                this.content[parentN] = element;\n                this.content[n] = parent;\n                // Update 'n' to continue at the new position.\n                n = parentN;\n            }\n            // Found a parent that is less, no need to sink any further.\n            else {\n                break;\n            }\n        }\n    }\n    private bubbleUp(n: number): void {\n        // Look up the target element and its score.\n        const length = this.content.length,\n            element = this.content[n],\n            elemScore = this.scoreFunction(element);\n        let conditionMet = true;\n        while (conditionMet) {\n            // Compute the indices of the child elements.\n            const child2N = (n + 1) << 1,\n                child1N = child2N - 1;\n            // This is used to store the new position of the element, if any.\n            let swap = null,\n                child1Score;\n            // If the first child exists (is inside the array)...\n            if (child1N < length) {\n                // Look it up and compute its score.\n                const child1 = this.content[child1N];\n                child1Score = this.scoreFunction(child1);\n\n                // If the score is less than our element's, we need to swap.\n                if (child1Score < elemScore) {\n                    swap = child1N;\n                }\n            }\n\n            // Do the same checks for the other child.\n            if (child2N < length) {\n                const child2 = this.content[child2N],\n                    child2Score = this.scoreFunction(child2);\n                if (child2Score < (swap === null ? elemScore : child1Score)) {\n                    swap = child2N;\n                }\n            }\n\n            // If the element needs to be moved, swap it, and continue.\n            if (swap !== null) {\n                this.content[n] = this.content[swap];\n                this.content[swap] = element;\n                n = swap;\n            }\n            // Otherwise, we are done.\n            else {\n                conditionMet = false;\n                break;\n            }\n        }\n    }\n}\n","import { BinaryHeap } from './BinaryHeap';\nimport { GridNode } from './GridNode';\n\nexport type PathFindingHeuristicFunction = (pos0: GridNode, pos1: GridNode) => number;\nexport type PathFindingSearchOptions = {\n    heuristic?: PathFindingHeuristicFunction;\n    closest?: boolean;\n};\nexport type PathFindingOptions = {\n    diagonal?: boolean;\n    closest?: boolean;\n};\n\n// Based on http://github.com/bgrins/javascript-astar v0.4.0\n\n/**\n * Includes all path finding logic.\n *\n * @class PathFinding\n */\nexport class PathFinding {\n    /**\n     * @property {Array(Array(GridNode))} grid\n     * @private\n     */\n    private grid: GridNode[][];\n    /**\n     * @property {boolean} diagonal\n     * @private\n     */\n    private diagonal: boolean;\n    /**\n     * Active heuristic method to use\n     * @property\n     * @private\n     */\n    private heuristic: PathFindingHeuristicFunction;\n\n    private closest: boolean;\n\n    private nodes: GridNode[];\n    private dirtyNodes: GridNode[];\n\n    /**\n     * See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n     *\n     * @property\n     * @private\n     * @static\n     */\n    private static readonly HEURISTICS: {\n        [key in 'manhattan' | 'diagonal']: PathFindingHeuristicFunction;\n    } = {\n        manhattan: (pos0: GridNode, pos1: GridNode) => {\n            const d1 = Math.abs(pos1.x - pos0.x);\n            const d2 = Math.abs(pos1.y - pos0.y);\n            return d1 + d2;\n        },\n        diagonal: (pos0: GridNode, pos1: GridNode) => {\n            const D = 1;\n            const D2 = Math.sqrt(2);\n            const d1 = Math.abs(pos1.x - pos0.x);\n            const d2 = Math.abs(pos1.y - pos0.y);\n            return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);\n        },\n    };\n    /**\n     * Constructor function for the PathFinding class.\n     *\n     * @constructor\n     *\n     * @param mapSizeC {number} number of columns\n     * @param mapSizeR {number} number of rows\n     * @param options {PathFindingOptions}  settings for the search algorithm, default `{}`\n     */\n    constructor(mapSizeC: number, mapSizeR: number, options: PathFindingOptions = {}) {\n        //define map\n        this.nodes = [];\n        this.diagonal = !!options.diagonal;\n        this.heuristic = this.diagonal ? PathFinding.HEURISTICS.diagonal : PathFinding.HEURISTICS.manhattan;\n        this.closest = !!options.closest;\n        this.grid = [];\n        let c = 0,\n            r = 0,\n            node: GridNode;\n        for (c = 0; c < mapSizeC; c++) {\n            this.grid[c] = [];\n            for (r = 0; r < mapSizeR; r++) {\n                node = new GridNode(c, r, 1);\n                this.grid[c][r] = node;\n                this.nodes.push(node);\n            }\n        }\n        this.init();\n    }\n\n    /**\n     * Cleans/resets all nodes.\n     *\n     * @method init\n     * @private\n     */\n    private init(): void {\n        this.dirtyNodes = [];\n        for (let i = 0; i < this.nodes.length; i++) {\n            this.cleanNode(this.nodes[i]);\n        }\n    }\n\n    // /**\n    //  * Cleans only dirty nodes.\n    //  *\n    //  * @method cleanDirty\n    //  * @private\n    //  */\n    // private cleanDirty(): void {\n    //     for (let i = 0; i < this.dirtyNodes.length; i++) {\n    //         this.cleanNode(this.dirtyNodes[i]);\n    //     }\n    //     this.dirtyNodes = [];\n    // }\n\n    /**\n     * Marks a node as dirty.\n     *\n     * @method markDirty\n     * @private\n     * @param node {TRAVISO.PathFinding.GridNode} node to be marked\n     */\n    private markDirty(node: GridNode): void {\n        this.dirtyNodes.push(node);\n    }\n\n    /**\n     * Finds adjacent/neighboring cells of a single node.\n     *\n     * @method neighbors\n     * @param node {TRAVISO.PathFinding.GridNode} source node\n     * @return {Array(TRAVISO.PathFinding.GridNode)} an array of available cells\n     */\n    private neighbors(node: GridNode): GridNode[] {\n        const ret = [],\n            x = node.x,\n            y = node.y,\n            grid = this.grid;\n\n        // West\n        if (grid[x - 1] && grid[x - 1][y]) {\n            ret.push(grid[x - 1][y]);\n        }\n        // East\n        if (grid[x + 1] && grid[x + 1][y]) {\n            ret.push(grid[x + 1][y]);\n        }\n        // South\n        if (grid[x] && grid[x][y - 1]) {\n            ret.push(grid[x][y - 1]);\n        }\n        // North\n        if (grid[x] && grid[x][y + 1]) {\n            ret.push(grid[x][y + 1]);\n        }\n\n        if (this.diagonal) {\n            // Southwest\n            if (grid[x - 1] && grid[x - 1][y - 1]) {\n                ret.push(grid[x - 1][y - 1]);\n            }\n            // Southeast\n            if (grid[x + 1] && grid[x + 1][y - 1]) {\n                ret.push(grid[x + 1][y - 1]);\n            }\n            // Northwest\n            if (grid[x - 1] && grid[x - 1][y + 1]) {\n                ret.push(grid[x - 1][y + 1]);\n            }\n            // Northeast\n            if (grid[x + 1] && grid[x + 1][y + 1]) {\n                ret.push(grid[x + 1][y + 1]);\n            }\n        }\n        return ret;\n    }\n\n    public toString(): string {\n        const graphString: string[] = [],\n            nodes = this.grid; // when using grid\n        let rowDebug: number[], row: GridNode[], x: number, len: number, y: number, l: number;\n        for (x = 0, len = nodes.length; x < len; x++) {\n            rowDebug = [];\n            row = nodes[x];\n            for (y = 0, l = row.length; y < l; y++) {\n                rowDebug.push(row[y].weight);\n            }\n            graphString.push(rowDebug.join(' '));\n        }\n        return graphString.join('\\n');\n    }\n\n    /**\n     * Solves path finding for the given source and destination locations.\n     *\n     * @method solve\n     * @private\n     * @param originC {number} column index of the source location\n     * @param originR {number} row index of the source location\n     * @param destC {number} column index of the destination location\n     * @param destR {number} row index of the destination location\n     * @return {Array(Object)} solution path\n     */\n    public solve(originC: number, originR: number, destC: number, destR: number): GridNode[] {\n        const start = this.grid[originC][originR];\n        const end = this.grid[destC][destR];\n        const result = this.search(start, end, {\n            heuristic: this.heuristic,\n            closest: this.closest,\n        });\n        return result && result.length > 0 ? result : null;\n    }\n\n    /**\n     * Finds available adjacent cells of an area defined by location and size.\n     *\n     * @method getAdjacentOpenCells\n     * @param cellC {number} column index of the location\n     * @param cellR {number} row index of the location\n     * @param sizeC {number} column size of the area\n     * @param sizeR {number} row size of the area\n     * @return {Array(Object)} an array of available cells\n     */\n    public getAdjacentOpenCells(cellC: number, cellR: number, sizeC: number, sizeR: number): GridNode[] {\n        let r: number,\n            c: number,\n            cellArray: GridNode[] = [];\n        for (r = cellR; r > cellR - sizeR; r--) {\n            for (c = cellC; c < cellC + sizeC; c++) {\n                // NOTE: concat is browser dependent. It is fastest for Chrome. Might be a good idea to use for loop or \"a.push.apply(a, b);\" for other browsers\n                cellArray = cellArray.concat(this.neighbors(this.grid[c][r]));\n            }\n        }\n        return cellArray;\n    }\n\n    private pathTo(node: GridNode): GridNode[] {\n        let curr = node;\n        const path: GridNode[] = [];\n        while (curr.parent) {\n            path.push(curr);\n            curr = curr.parent;\n        }\n        // return path.reverse();\n        return path;\n    }\n\n    private getHeap(): BinaryHeap {\n        return new BinaryHeap((node: unknown) => (node as GridNode).f);\n    }\n\n    /**\n     * Perform an A* Search on a graph given a start and end node.\n     *\n     * @method\n     * @function\n     * @private\n     *\n     * @param start {GridNode} beginning node of search\n     * @param end {GridNode} end node of the search\n     * @param options {Object} Search options\n     * @return {Array(GridNode)} resulting list of nodes\n     */\n    private search(start: GridNode, end: GridNode, options: PathFindingSearchOptions = {}): GridNode[] {\n        this.init();\n\n        const heuristic = options.heuristic || PathFinding.HEURISTICS.manhattan;\n        const closest = options.closest || false;\n\n        const openHeap = this.getHeap();\n        let closestNode = start; // set the start node to be the closest if required\n\n        start.h = heuristic(start, end);\n\n        openHeap.push(start);\n\n        while (openHeap.size() > 0) {\n            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n            const currentNode: GridNode = openHeap.pop() as GridNode;\n\n            // End case -- result has been found, return the traced path.\n            if (currentNode === end) {\n                return this.pathTo(currentNode);\n            }\n\n            // Normal case -- move currentNode from open to closed, process each of its neighbors.\n            currentNode.closed = true;\n\n            // Find all neighbors for the current node.\n            const neighbors = this.neighbors(currentNode);\n\n            for (let i = 0, il = neighbors.length; i < il; ++i) {\n                const neighbor = neighbors[i];\n\n                if (neighbor.closed || neighbor.isWall()) {\n                    // Not a valid node to process, skip to next neighbor.\n                    continue;\n                }\n\n                // The g score is the shortest distance from start to current node.\n                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n                const gScore = currentNode.g + neighbor.getCost(currentNode),\n                    beenVisited = neighbor.visited;\n\n                if (!beenVisited || gScore < neighbor.g) {\n                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n                    neighbor.visited = true;\n                    neighbor.parent = currentNode;\n                    neighbor.h = neighbor.h || heuristic(neighbor, end);\n                    neighbor.g = gScore;\n                    neighbor.f = neighbor.g + neighbor.h;\n                    this.markDirty(neighbor);\n                    if (closest) {\n                        // If the neighbor is closer than the current closestNode or if it's equally close but has\n                        // a cheaper path than the current closest node then it becomes the closest node\n                        if (\n                            neighbor.h < closestNode.h ||\n                            (neighbor.h === closestNode.h && neighbor.g < closestNode.g)\n                        ) {\n                            closestNode = neighbor;\n                        }\n                    }\n\n                    if (!beenVisited) {\n                        // Pushing to heap will put it in proper place based on the 'f' value.\n                        openHeap.push(neighbor);\n                    } else {\n                        // Already seen the node, but since it has been re-scored we need to reorder it in the heap\n                        openHeap.rescoreElement(neighbor);\n                    }\n                }\n            }\n        }\n\n        if (closest) {\n            return this.pathTo(closestNode);\n        }\n\n        // No result was found - empty array signifies failure to find path.\n        return [];\n    }\n\n    private cleanNode(node: GridNode): void {\n        node.f = 0;\n        node.g = 0;\n        node.h = 0;\n        node.visited = false;\n        node.closed = false;\n        node.parent = null;\n    }\n\n    /**\n     * Checks if the location is occupied/available or not.\n     *\n     * @method isCellFilled\n     * @param c {number} column index of the location\n     * @param r {number} row index of the location\n     * @return {Array(Object)} if the location is not available\n     */\n    public isCellFilled(c: number, r: number): boolean {\n        if (this.grid[c][r].weight === 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Sets individual cell state for ground layer.\n     *\n     * @method setCell\n     * @param c {number} column index of the location\n     * @param r {number} row index of the location\n     * @param movable {boolean} free to move or not\n     */\n    public setCell(c: number, r: number, movable: number): void {\n        this.grid[c][r].staticWeight = this.grid[c][r].weight = movable;\n    }\n\n    /**\n     * Sets individual cell state for objects layer.\n     *\n     * @method setDynamicCell\n     * @param c {number} column index of the location\n     * @param r {number} row index of the location\n     * @param movable {boolean} free to move or not\n     */\n    public setDynamicCell(c: number, r: number, movable: number): void {\n        // if it is movable by static tile property\n        if (this.grid[c][r].staticWeight !== 0) {\n            this.grid[c][r].weight = movable;\n        }\n    }\n\n    /**\n     * Clears all references.\n     *\n     * @method\n     * @function\n     * @public\n     */\n    public destroy(): void {\n        this.grid = null;\n        this.nodes = null;\n        this.dirtyNodes = null;\n        this.heuristic = null;\n    }\n}\n","import { DisplayObject } from 'pixi.js';\nimport { TPositionPair } from './map';\n\n/**\n * Checks if the value existy.\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @method\n * @function\n * @public\n * @static\n *\n * @param value {unknown} value to check\n * @return {boolean} if the value existy or not\n */\nexport const existy = (value: unknown): boolean => {\n    return value !== null && value !== undefined;\n};\n\n/**\n * Linear maps a given number in a source range to a target range\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @method\n * @function\n * @public\n * @static\n *\n * @param v {number} value to map\n * @param min1 {number} minimum value of the source range\n * @param max1 {number} maximum value of the source range\n * @param min2 {number} minimum value of the target range\n * @param max2 {number} maximum value of the target range\n * @param noOutliers {boolean} If the outlier values won't be processed, default false\n * @return {number} mapped value according to target range\n */\nexport const mathMap = (\n    v: number,\n    min1: number,\n    max1: number,\n    min2: number,\n    max2: number,\n    noOutliers: boolean = false\n): number => {\n    if (noOutliers) {\n        if (v < min1) {\n            return min2;\n        } else if (v > max1) {\n            return max2;\n        }\n    }\n    return min2 + ((max2 - min2) * (v - min1)) / (max1 - min1);\n};\n\n/**\n * Produces dot product of two vectors.\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @method\n * @function\n * @public\n * @static\n *\n * @param v1 {TPositionPair} first vector\n * @param v2 {TPositionPair} second vector\n * @return {number} dot product of two vectors\n */\nexport const dotProduct = (v1: TPositionPair, v2: TPositionPair): number => {\n    return v1.x * v2.x + v1.y * v2.y;\n};\n\n/**\n * Produces unit vector of a given vector.\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @method\n * @function\n * @public\n * @static\n *\n * @param v {TPositionPair} source vector\n * @return {TPositionPair} unit vector\n */\nexport const getUnit = (v: TPositionPair): TPositionPair => {\n    const m = Math.sqrt(v.x * v.x + v.y * v.y);\n    return { x: v.x / m, y: v.y / m };\n};\n\n/**\n * Checks if the given point is the polygon defined by the vertices.\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @method\n * @function\n * @public\n * @static\n *\n * @param gp {TPositionPair} point to check\n * @param vertices {Array(Array(Number))} array containing the vertices of the polygon\n * @return {boolean} if the point is inside the polygon\n */\nexport const isInPolygon = (gp: TPositionPair, vertices: number[][]): boolean => {\n    const testY = gp.y;\n    const testX = gp.x;\n    const nVert = vertices.length;\n    let i,\n        j,\n        c = false;\n    for (i = 0, j = nVert - 1; i < nVert; j = i++) {\n        if (\n            vertices[i][1] > testY !== vertices[j][1] > testY &&\n            testX <\n                ((vertices[j][0] - vertices[i][0]) * (testY - vertices[i][1])) / (vertices[j][1] - vertices[i][1]) +\n                    vertices[i][0]\n        ) {\n            c = !c;\n        }\n    }\n    return c;\n};\n\n/**\n * Calculates the distance between two points.\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @method\n * @function\n * @public\n * @static\n *\n * @param p1 {TPositionPair} first point\n * @param p2 {TPositionPair} second point\n * @return {number} the distance between two points\n */\nexport const getDist = (p1: TPositionPair, p2: TPositionPair): number => {\n    return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));\n};\n\n/**\n * Calculates the global point with respect to given local point and scope.\n *\n * @method\n * @function\n * @private\n * @internal\n * @static\n *\n * @param lp {TPositionPair} local point\n * @param scope {PIXI.DisplayObject} local scope\n * @return {TPositionPair} global point\n */\nexport const localToGlobal = (lp: TPositionPair, scope: DisplayObject): TPositionPair => {\n    let sX = scope.position.x + lp.x;\n    let sY = scope.position.y + lp.y;\n\n    let p = scope.parent;\n    while (p) {\n        sX += p.position.x;\n        sY += p.position.y;\n        p = p.parent;\n    }\n\n    return {\n        x: sX,\n        y: sY,\n    };\n};\n\n/**\n * Calculates the local point with respect to given global point and local scope.\n *\n * @method\n * @function\n * @private\n * @internal\n * @static\n *\n * @param gp {TPositionPair} global point\n * @param scope {PIXI.DisplayObject} local scope\n * @return {TPositionPair} local point\n */\nexport const globalToLocal = (gp: TPositionPair, scope: DisplayObject): TPositionPair => {\n    let sX = scope.position.x;\n    let sY = scope.position.y;\n\n    let p = scope.parent;\n    while (p) {\n        sX += p.position.x;\n        sY += p.position.y;\n        p = p.parent;\n    }\n\n    return {\n        x: gp.x - sX,\n        y: gp.y - sY,\n    };\n};\n","import { ObjectVisualKey } from './map';\n\nexport type TDirection = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n/** Type declaration for reserved direction IDs */\nexport type TDirections = {\n    /** idle, no direction */\n    readonly O: 0;\n    /** south */\n    readonly S: 1;\n    /** south-west */\n    readonly SW: 2;\n    /** west */\n    readonly W: 3;\n    /** north-west */\n    readonly NW: 4;\n    /** north */\n    readonly N: 5;\n    /** north-east */\n    readonly NE: 6;\n    /** east */\n    readonly E: 7;\n    /** south-east */\n    readonly SE: 8;\n};\n\n// export type Traviso = {\n//     DIRECTIONS: TDirections,\n\n// }\n\n/**\n * The direction IDs to be used in the engine\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @property\n * @static\n * @public\n * @constant\n */\nexport const DIRECTIONS: Readonly<TDirections> = {\n    O: 0,\n    S: 1,\n    SW: 2,\n    W: 3,\n    NW: 4,\n    N: 5,\n    NE: 6,\n    E: 7,\n    SE: 8,\n};\n\nexport type TReservedTextureIDs = ObjectVisualKey[];\n/**\n * Texture IDs reserved for internal use\n *\n * @static\n * @private\n * @constant\n * @property\n * @internal\n */\nexport const RESERVED_TEXTURE_IDS: Readonly<TReservedTextureIDs> = [\n    'idle',\n    'idle_s',\n    'idle_sw',\n    'idle_w',\n    'idle_nw',\n    'idle_n',\n    'idle_ne',\n    'idle_e',\n    'idle_se',\n    'move_s',\n    'move_sw',\n    'move_w',\n    'move_nw',\n    'move_n',\n    'move_ne',\n    'move_e',\n    'move_se',\n];\n\n/** Type declaration for the IDs of available path finding algorithms */\nexport type TPathFindingAlgorithmID = 0 | 1;\n/** Type declaration for available path finding algorithms */\nexport type TPathFindingAlgorithms = {\n    readonly ASTAR_ORTHOGONAL: TPathFindingAlgorithmID;\n    readonly ASTAR_DIAGONAL: TPathFindingAlgorithmID;\n};\n/**\n * The types of available path finding algorithms\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @property\n * @static\n * @public\n * @constant\n */\nexport const PF_ALGORITHMS: Readonly<TPathFindingAlgorithms> = {\n    ASTAR_ORTHOGONAL: 0,\n    ASTAR_DIAGONAL: 1,\n};\n\nexport const KEY_EMPTY_TILE: string = '0';\nexport const KEY_NO_OBJECTS: string = '0';\n","let logEnabled: boolean = true;\n\n/**\n * Writes logs to the browser console\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @method\n * @function\n * @public\n * @static\n *\n * @param s {string} text to log\n */\nexport function trace(s: string): void {\n    if (logEnabled) {\n        // eslint-disable-next-line no-console\n        self.console.log('TRAVISO: ' + s);\n    }\n}\n\n/**\n * Determines if TRAVISO can log helper text.\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @method\n * @function\n * @public\n * @static\n *\n * @param enabled {boolean} enable logging or not, default `true`\n * @return {boolean} logging enabled or not\n */\nexport function enableDisableLogging(enabled: boolean = true): boolean {\n    return (logEnabled = enabled);\n}\n","import { Texture } from 'pixi.js';\nimport { EngineView } from '../map/EngineView';\nimport { TDirection, DIRECTIONS, RESERVED_TEXTURE_IDS } from './constants';\nimport { trace } from './trace';\n\nexport type ObjectVisualKey =\n    | 'idle'\n    | 'idle_s'\n    | 'idle_sw'\n    | 'idle_w'\n    | 'idle_nw'\n    | 'idle_n'\n    | 'idle_ne'\n    | 'idle_e'\n    | 'idle_se'\n    | 'move_s'\n    | 'move_sw'\n    | 'move_w'\n    | 'move_nw'\n    | 'move_n'\n    | 'move_ne'\n    | 'move_e'\n    | 'move_se'\n    | string;\n/** Type declaration for column-row pair objects */\nexport type TColumnRowPair = {\n    /** column index of the column-row pair */\n    c: number;\n    /** row index of the column-row pair */\n    r: number;\n};\n/** Type declaration for x-y position pair objects */\nexport type TPositionPair = {\n    /** x position of the pair */\n    x: number;\n    /** y position of the pair */\n    y: number;\n};\nexport type ObjectInfoTextures = { [key in ObjectVisualKey]: Texture[] };\nexport type ObjectInfoTextureNames = { [key in ObjectVisualKey]: string[] };\nexport type ObjectInfoInteractionOffsets = {\n    [key in ObjectVisualKey]: TColumnRowPair;\n};\n\nexport type TTileInfo = {\n    m: boolean;\n    t: Texture[];\n};\n\nexport type MapDataObjectVisualFrame = { path: string };\n\nexport type MapDataObjectVisual = {\n    frames: MapDataObjectVisualFrame[];\n    path: string;\n    extension: string;\n    numberOfFrames: number;\n    startIndex: number;\n    ipoc: number;\n    ipor: number;\n};\n\nexport type MapDataObjectVisuals = {\n    [key in ObjectVisualKey]: MapDataObjectVisual;\n};\n\nexport type MapDataTile = { movable: boolean; path: string };\nexport type MapDataTiles = {\n    [key: string]: MapDataTile;\n};\n\nexport interface IObjectInfo {\n    m: boolean;\n    i: boolean;\n    nt: boolean;\n    f: boolean;\n    s: unknown; // TODO: This is probably not being used any more\n    t: ObjectInfoTextures;\n    /** Interaction offsets for each visual defined for the object */\n    io: ObjectInfoInteractionOffsets;\n    rowSpan: number;\n    columnSpan: number;\n}\nexport interface IMapDataObject extends IObjectInfo {\n    movable: boolean;\n    interactive: boolean;\n    noTransparency: boolean;\n    floor: boolean;\n    visuals: MapDataObjectVisuals;\n    // added by engine\n    id: string;\n    textureNames: ObjectInfoTextureNames;\n}\nexport type TMapDataObjects = {\n    [key: string]: IMapDataObject;\n};\n\n/** Type declaration for processed map data */\nexport type TMapData = {\n    tiles: MapDataTiles;\n    objects: TMapDataObjects;\n    initialControllableLocation: {\n        columnIndex: number;\n        rowIndex: number;\n        controllableId: string;\n    };\n    tileHighlightImage: {\n        path: string;\n    };\n    singleGroundImage: {\n        path: string;\n        scale: number;\n    };\n    groundMap: Array<{ row: string }>;\n    objectsMap: Array<{ row: string }>;\n    // added by engine\n    groundMapData: string[][];\n    objectsMapData: string[][];\n};\n\n/**\n * Returns an object with all properties of a map-object defined by object-type\n *\n * @method\n * @function\n * @private\n * @static\n *\n * @param engine {EngineView} engine instance\n * @param objectType {string} type/id of the related object tag defined in the json file\n * @return {IObjectInfo} an object with certain properties of a map-object\n */\nexport const getObjectInfo = (engine: EngineView, objectType: string): IObjectInfo => {\n    const objInfo: IMapDataObject = engine.mapData.objects[objectType];\n    if (objInfo) {\n        const textures: ObjectInfoTextures = {};\n        for (const key in objInfo.textureNames) {\n            if (Object.prototype.hasOwnProperty.call(objInfo.textureNames, key)) {\n                textures[key] = getObjectTextures(engine, objectType, key);\n            }\n        }\n        return {\n            m: objInfo.m,\n            i: objInfo.i,\n            f: objInfo.f,\n            nt: objInfo.nt,\n            t: textures,\n            io: objInfo.io,\n            s: objInfo.s,\n            rowSpan: objInfo.rowSpan,\n            columnSpan: objInfo.columnSpan,\n        };\n    }\n\n    throw new Error('TRAVISO: No info defined for object type: ' + objectType);\n};\n/**\n * Returns an array of textures {PIXI.Texture} belong to a map-object defined by object-type and sprite-id\n *\n * @function getObjectTextures\n * @memberof TRAVISO\n * @static\n * @private\n * @param engine {EngineView} engine instance\n * @param objectType {string} type/id of the related object tag defined in the json file\n * @param visualId {string} id of the related v tag defined in the json file\n * @return {Array(PIXI.Texture)} an array of textures\n */\nexport const getObjectTextures = (engine: EngineView, objectType: string, visualId: ObjectVisualKey): Texture[] => {\n    const objInfo: IMapDataObject = engine.mapData.objects[objectType];\n    if (objInfo) {\n        let textures = null;\n        const textureNames = objInfo.textureNames[visualId];\n        if (textureNames && textureNames.length > 0) {\n            textures = [];\n            for (let j = 0; j < textureNames.length; j++) {\n                textures[textures.length] = Texture.from(textureNames[j]);\n            }\n        } else {\n            trace('No textures defined for object type: ' + objectType + ' and visualId: ' + visualId);\n        }\n        return textures;\n    }\n\n    throw new Error('TRAVISO: No info defined for object type: ' + objectType);\n};\n\n/**\n * Returns an object with all properties of a map-tile defined by tileType\n *\n * @method\n * @function\n * @static\n *\n * @param engine {EngineView} engine instance\n * @param tileType {string} type/id of the related tile tag defined in the json file\n * @return {TTileInfo} an information object with certain properties (movability and textures) of a map-tile\n */\nexport const getTileInfo = (engine: EngineView, tileType: string): TTileInfo => {\n    const tileInfo = engine.mapData.tiles[tileType];\n    if (tileInfo) {\n        return {\n            // m : tileInfo.m,\n            m: tileInfo.movable,\n            t: tileInfo.path ? [Texture.from(tileInfo.path)] : [],\n        };\n    } else if (engine.mapData.singleGroundImage) {\n        return {\n            m: parseInt(tileType) > 0,\n            t: [],\n        };\n    } else {\n        throw new Error('TRAVISO: No info defined for tile type: ' + tileType);\n    }\n};\n\n/**\n * Returns the predefined moving texture id for the given direction\n *\n * @method\n * @function\n * @static\n *\n * @param dir {TDirection} index of the direction\n * @return {ObjectVisualKey} texture id for the given direction\n */\nexport const getMovingDirVisualId = (dir: TDirection): ObjectVisualKey => {\n    return RESERVED_TEXTURE_IDS[dir + 8];\n};\n\n/**\n * Returns the predefined stationary texture id for the given direction\n *\n * @method\n * @function\n * @static\n *\n * @param dir {TDirection} index of the direction\n * @return {ObjectVisualKey} texture id for the given direction\n */\nexport const getStationaryDirVisualId = (dir: TDirection): ObjectVisualKey => {\n    return RESERVED_TEXTURE_IDS[dir];\n};\n\n/**\n * Returns the direction (id) between two locations\n *\n * @function getDirBetween\n * @memberof TRAVISO\n * @static\n * @private\n * @param r1 {number} row index of the first location\n * @param c1 {number} column index of the first location\n * @param r2 {number} row index of the second location\n * @param c2 {number} column index of the second location\n * @return {TDirection} direction id\n */\nexport const getDirBetween = (r1: number, c1: number, r2: number, c2: number): TDirection => {\n    let dir: TDirection = DIRECTIONS.S;\n    if (r1 === r2) {\n        if (c1 === c2) {\n            dir = DIRECTIONS.O;\n        } else if (c1 < c2) {\n            dir = DIRECTIONS.NE;\n        } else {\n            dir = DIRECTIONS.SW;\n        }\n    } else if (r1 < r2) {\n        if (c1 === c2) {\n            dir = DIRECTIONS.SE;\n        } else if (c1 < c2) {\n            dir = DIRECTIONS.E;\n        } else {\n            dir = DIRECTIONS.S;\n        }\n    } else if (r1 > r2) {\n        if (c1 === c2) {\n            dir = DIRECTIONS.NW;\n        } else if (c1 < c2) {\n            dir = DIRECTIONS.N;\n        } else {\n            dir = DIRECTIONS.W;\n        }\n    }\n    return dir;\n};\n","export type EasingType =\n    | 'easeInOut'\n    | 'easeInOutQuad'\n    | 'Quad.easeInOut'\n    | 'easeIn'\n    | 'easeInQuad'\n    | 'Quad.easeIn'\n    | 'easeOut'\n    | 'easeOutQuad'\n    | 'Quad.easeOut'\n    | 'linear';\nexport type EasingFunction = (t: number, b: number, c: number, d: number) => number;\n/**\n * Returns the proper easing method to use depending on the easing id specified.\n *\n * @method getEasingFunc\n * @private\n * @param e {string} the easing id\n * @return {Function} the easing method to use\n */\nexport const getEasingFunc = (e: EasingType): EasingFunction => {\n    if (e === 'easeInOut' || e === 'easeInOutQuad' || e === 'Quad.easeInOut') {\n        return easeInOutQuad;\n    } else if (e === 'easeIn' || e === 'easeInQuad' || e === 'Quad.easeIn') {\n        return easeInQuad;\n    } else if (e === 'easeOut' || e === 'easeOutQuad' || e === 'Quad.easeOut') {\n        return easeOutQuad;\n    } else {\n        return linearTween;\n    }\n};\n\n/**\n * Linear tween calculation.\n *\n * @method linearTween\n * @private\n * @param t {number} current time\n * @param b {number} initial value\n * @param c {number} difference with the target value\n * @param d {number} total time\n * @return {number} result of the calculation\n */\nexport const linearTween = (t: number, b: number, c: number, d: number): number => {\n    return (c * t) / d + b;\n};\n/**\n * Quadratic ease-in tween calculation.\n *\n * @method easeInQuad\n * @private\n * @param t {number} current time\n * @param b {number} initial value\n * @param c {number} difference with the target value\n * @param d {number} total time\n * @return {number} result of the calculation\n */\nexport const easeInQuad = (t: number, b: number, c: number, d: number): number => {\n    t /= d;\n    return c * t * t + b;\n};\n\n/**\n * Quadratic ease-out tween calculation.\n *\n * @method easeOutQuad\n * @private\n * @param t {number} current time\n * @param b {number} initial value\n * @param c {number} difference with the target value\n * @param d {number} total time\n * @return {number} result of the calculation\n */\nexport const easeOutQuad = (t: number, b: number, c: number, d: number): number => {\n    t /= d;\n    return -c * t * (t - 2) + b;\n};\n/**\n * Quadratic ease-in-out tween calculation.\n *\n * @method easeInOutQuad\n * @private\n * @param t {number} current time\n * @param b {number} initial value\n * @param c {number} difference with the target value\n * @param d {number} total time\n * @return {number} result of the calculation\n */\nexport const easeInOutQuad = (t: number, b: number, c: number, d: number): number => {\n    t /= d / 2;\n    if (t < 1) {\n        return (c / 2) * t * t + b;\n    }\n    t--;\n    return (-c / 2) * (t * (t - 2) - 1) + b;\n};\n","/**\n * @author Hakan Karlidag - @axaq\n */\n\nimport { Ticker } from 'pixi.js';\nimport { trace } from '../utils/trace';\nimport { EngineView } from '../map/EngineView';\nimport { ObjectView } from '../map/ObjectView';\nimport { GridNode } from '../pathFinding/GridNode';\nimport { getDist, getUnit } from '../utils/calculations';\nimport { EasingFunction, EasingType, getEasingFunc } from '../utils/easing';\nimport { TColumnRowPair, TPositionPair } from '../utils/map';\n\nexport interface IMovable extends ObjectView {\n    // [key: string]: any,\n    speedUnit: TPositionPair;\n    speedMagnitude: number;\n    currentPath: GridNode[];\n    currentPathStep: number;\n    currentTarget: TPositionPair;\n    currentTargetTile: GridNode;\n    currentReachThresh: number;\n    prevPosition: TPositionPair;\n}\n\nexport interface ITween {\n    target: { [key: string]: unknown };\n    duration: number;\n    delay: number;\n    easingFunc: EasingFunction;\n    overwrite: boolean;\n    onComplete: () => void;\n    totalFrames: number;\n    currentFrame: number;\n    vars: { [key: string]: { b: number; c: number } };\n}\n\nexport interface ITweenTarget {\n    [key: string]: unknown;\n    tweens?: ITween[];\n}\n\n/**\n * Holds and manages all the logic for tween animations and map-object movement on the map.\n * This is created and used by EngineView instances.\n *\n * @class MoveEngine\n */\nexport class MoveEngine {\n    /**\n     * A reference to the engine view that uses this move engine.\n     * @property\n     * @private\n     */\n    private _engine: EngineView;\n\n    /**\n     * The speed value to be used for object movements if not defined specifically.\n     * @property\n     * @private\n     * @default `3`\n     */\n    private _defaultSpeed: number;\n    /**\n     * Specifies if the move-engine will process the object movements.\n     * @property\n     * @private\n     * @default `false`\n     */\n    private _activeForMovables: boolean = false;\n    /**\n     * Specifies if the move-engine will process the tweens.\n     * @property\n     * @private\n     * @default `false`\n     */\n    private _activeForTweens: boolean = false;\n    /**\n     * Specifies if the move-engine will process the tweens and object movements.\n     * @property\n     * @private\n     * @default `true`\n     */\n    private _processFrame: boolean = true;\n    /**\n     * The list to store current map-objects in move.\n     * @property\n     * @private\n     * @default `[]`\n     */\n    private _movables: IMovable[] = [];\n    /**\n     * The list to store targets for the current tweens.\n     * @property\n     * @private\n     * @default `[]`\n     */\n    private _tweenTargets: ITweenTarget[] = [];\n    /**\n     * Used to calculate how many frames a tween will take to process.\n     * @property\n     * @private\n     * @default `60`\n     */\n    private _fps: number = 60;\n\n    private _ticker: Ticker;\n    private _processFunc: () => void;\n\n    /**\n     * Constructor function for MoveEngine.\n     *\n     * @constructor\n     *\n     * @param engine {EngineView} the engine instance that the animations will perform on\n     * @param defaultSpeed {number} default speed for the map-objects to be used when they move on map, default 3\n     */\n    constructor(engine: EngineView, defaultSpeed: number = 3) {\n        this._engine = engine;\n        this._defaultSpeed = defaultSpeed;\n\n        this._processFunc = this.run.bind(this);\n        this._ticker = new Ticker();\n        this._ticker.add(this._processFunc);\n        this._ticker.start();\n    }\n\n    /**\n     * Adds a single tween for the given object.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param o {ITweenTarget} the object to add tween animation to\n     * @param duration {number} the duration of the tween animation in seconds\n     * @param vars {{ [key: string]: number }} the object defining which properties of the target object will be animated\n     * @param delay {number} the amount of waiting before the tween animation starts, in seconds, default `0`\n     * @param easing {EasingType} type of the easing, default `'linear'`\n     * @param overwrite {boolean} if the other tween animations assigned to the same object are going to be killed, default `false`\n     * @param onComplete {Function} callback function to be called after the tween animation finished, default `null`\n     */\n    public addTween(\n        o: ITweenTarget,\n        duration: number,\n        vars: { [key: string]: number },\n        delay: number = 0,\n        easing: EasingType = 'linear',\n        overwrite: boolean = false,\n        onComplete: () => void = null\n    ): void {\n        let v: { [key: string]: { b: number; c: number } } = null;\n        for (const prop in vars) {\n            if (o[prop] !== vars[prop]) {\n                if (!v) {\n                    v = {};\n                }\n                v[prop] = { b: o[prop] as number, c: vars[prop] - (o[prop] as number) };\n            }\n        }\n\n        if (v) {\n            const t: ITween = {\n                target: o,\n                duration: duration,\n                delay: Number(delay) || 0,\n                easingFunc: getEasingFunc(easing),\n                overwrite: overwrite || false,\n                onComplete: onComplete || null,\n                totalFrames: duration * this._fps,\n                currentFrame: 0,\n                vars: v,\n            };\n\n            const idx = this._tweenTargets.indexOf(o);\n            if (idx >= 0) {\n                let tweens: ITween[] = o.tweens;\n                if (!tweens) {\n                    tweens = [];\n                }\n                if (t.overwrite) {\n                    for (let i = 0; i < tweens.length; i++) {\n                        tweens[i] = null;\n                    }\n                    tweens = [];\n                }\n\n                tweens[tweens.length] = t;\n                o.tweens = tweens;\n            } else {\n                o.tweens = [t];\n                this._tweenTargets[this._tweenTargets.length] = o;\n            }\n\n            if (this._tweenTargets.length > 0 && !this._activeForTweens) {\n                this._activeForTweens = true;\n            }\n        }\n    }\n\n    /**\n     * Removes a single tween from the given object.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param o {ITweenTarget} the object to remove the tween animation from\n     * @param t {ITween} the tween to be removed from the object\n     * @return {boolean} if the tween is found and removed\n     */\n    public removeTween(o: ITweenTarget, t: ITween): boolean {\n        let targetRemoved = false;\n\n        if (o && t) {\n            const idx = this._tweenTargets.indexOf(o);\n            if (idx >= 0) {\n                if (this._tweenTargets[idx].tweens && this._tweenTargets[idx].tweens.length > 0) {\n                    const tweens = this._tweenTargets[idx].tweens;\n                    const idx2 = tweens.indexOf(t);\n                    if (idx2 >= 0) {\n                        t.onComplete = null;\n                        t.easingFunc = null;\n                        t.target = null;\n\n                        tweens.splice(idx2, 1);\n                        if (tweens.length === 0) {\n                            this._tweenTargets.splice(idx, 1);\n                            targetRemoved = true;\n                        }\n                    } else {\n                        throw new Error('No tween defined for this object');\n                    }\n                } else {\n                    throw new Error('No tween defined for this object');\n                }\n            } else {\n                throw new Error('No tween target defined for this object');\n            }\n\n            if (this._tweenTargets.length === 0) {\n                this._activeForTweens = false;\n            }\n        }\n\n        return targetRemoved;\n    }\n\n    /**\n     * Removes and kills all tweens assigned to the given object.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param o {ITweenTarget} the object to remove the tween animations from\n     * @return {boolean} if any tween is found and removed from the object specified\n     */\n    public killTweensOf(o: ITweenTarget): boolean {\n        let targetRemoved = false;\n\n        const idx = this._tweenTargets.indexOf(o);\n        if (idx >= 0) {\n            if (this._tweenTargets[idx].tweens && this._tweenTargets[idx].tweens.length > 0) {\n                const tweens = this._tweenTargets[idx].tweens;\n                for (let j = 0; j < tweens.length; j++) {\n                    tweens[j].onComplete = null;\n                    tweens[j].easingFunc = null;\n                    tweens[j].target = null;\n                    tweens[j] = null;\n                }\n                this._tweenTargets[idx].tweens = null;\n            }\n\n            this._tweenTargets.splice(idx, 1);\n\n            targetRemoved = true;\n        }\n\n        if (this._tweenTargets.length === 0) {\n            this._activeForTweens = false;\n        }\n\n        return targetRemoved;\n    }\n\n    /**\n     * Removes and kills all the tweens in operation currently.\n     *\n     * @method\n     * @function\n     * @private\n     */\n    private removeAllTweens(): void {\n        this._activeForTweens = false;\n\n        let tweens, i, j;\n        const len = this._tweenTargets.length;\n        for (i = 0; i < len; i++) {\n            tweens = this._tweenTargets[i].tweens;\n            for (j = 0; j < tweens.length; j++) {\n                tweens[j].onComplete = null;\n                tweens[j].easingFunc = null;\n                tweens[j].target = null;\n                tweens[j] = null;\n            }\n            this._tweenTargets[i].tweens = null;\n            this._tweenTargets[i] = null;\n        }\n\n        this._tweenTargets = [];\n    }\n\n    /**\n     * Adds a map-object as movable to the engine.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param o {IMovable} the map-object to add as movable\n     */\n    public addMovable(o: IMovable): void {\n        if (this._movables.indexOf(o) >= 0) {\n            return;\n        }\n\n        this._movables[this._movables.length] = o;\n\n        if (this._movables.length > 0 && !this._activeForMovables) {\n            this._activeForMovables = true;\n        }\n\n        // all movables needs to have the following variables:\n        // speedMagnitude, speedUnit (more to come...)\n\n        // NOTE: might be a good idea to add all necessary parameters to the object here\n    }\n\n    /**\n     * Removes a map-object from the current movables list.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param o {IMovable} the map-object to remove\n     * @return {boolean} if the map-object is removed or not\n     */\n    public removeMovable(o: IMovable): boolean {\n        const idx = this._movables.indexOf(o);\n        if (idx !== -1) {\n            o.speedUnit = { x: 0, y: 0 };\n            this._movables.splice(idx, 1);\n        }\n        if (this._movables.length === 0) {\n            this._activeForMovables = false;\n        }\n        // TODO: might be a good idea to remove/reset all related parameters from the object here\n\n        return idx !== -1;\n    }\n\n    /**\n     * Removes all movables.\n     *\n     * @method\n     * @function\n     * @private\n     */\n    private removeAllMovables(): void {\n        this._activeForMovables = false;\n\n        const len = this._movables.length;\n        for (let i = 0; i < len; i++) {\n            this._movables[i] = null;\n        }\n\n        this._movables = [];\n    }\n\n    /**\n     * Changes the current path of a map-object.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param o {IMovable} the map-object to add the path to\n     * @param path {Array(GridNode)} the new path\n     * @param speed {number} speed of the map-object to be used during movement, if not defined it uses previous speed or the MoveEngine's default speed, default null\n     */\n    public addNewPathToObject(o: IMovable, path: GridNode[], speed: number): void {\n        if (o.currentPath && o.currentTarget) {\n            path[path.length] = o.currentPath[o.currentPathStep];\n        }\n        o.currentPath = path;\n        o.currentPathStep = o.currentPath.length - 1;\n        o.speedMagnitude = speed || o.speedMagnitude || this._defaultSpeed;\n    }\n\n    /**\n     * Prepares a map-object for movement.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param o {IMovable} the movable map-object\n     * @param path {Array(GridNode)} the path for the object\n     * @param speed {number} speed of the map-object to be used during movement, if not defined it uses previous speed or the MoveEngine's default speed, default null\n     */\n    public prepareForMove(o: IMovable, path: GridNode[], speed: number = null): void {\n        o.currentPath = path;\n        o.currentPathStep = o.currentPath.length - 1;\n        o.speedMagnitude = speed || o.speedMagnitude || this._defaultSpeed;\n    }\n\n    /**\n     * Sets movement specific parameters for the map-object according to target location.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param o {IMovable} the movable map-object\n     * @param pos {TColumnRowPair} target location\n     */\n    public setMoveParameters(o: IMovable, pos: TColumnRowPair): void {\n        const px = this._engine.getTilePosXFor(pos.r, pos.c);\n        const py = this._engine.getTilePosYFor(pos.r, pos.c) + this._engine.tileHalfHeight;\n\n        o.speedUnit = getUnit({ x: px - o.position.x, y: py - o.position.y });\n\n        o.currentTarget = { x: px, y: py };\n        o.currentReachThresh = Math.ceil(\n            Math.sqrt(o.speedUnit.x * o.speedUnit.x + o.speedUnit.y * o.speedUnit.y) * o.speedMagnitude\n        );\n    }\n\n    /**\n     * Method that precesses a single frame.\n     *\n     * @method\n     * @function\n     * @private\n     */\n    private run(): void {\n        // NOTE: Write an alternative with a real time driven animator\n\n        if (this._processFrame) {\n            let len: number, o: IMovable, i: number;\n            if (this._activeForMovables) {\n                len = this._movables.length;\n\n                let dist;\n                for (i = 0; i < len; i++) {\n                    o = this._movables[i];\n\n                    // move object\n\n                    // speed vector (magnitude and direction)\n\n                    o.prevPosition = { x: o.position.x, y: o.position.y };\n\n                    // check for target reach\n                    if (o.currentTarget) {\n                        dist = getDist(o.position, o.currentTarget);\n                        if (dist <= o.currentReachThresh) {\n                            // reached to the target\n                            o.position.x = o.currentTarget.x;\n                            o.position.y = o.currentTarget.y;\n\n                            this._engine.onObjMoveStepEnd(o);\n                            i--;\n                            len--;\n                            continue;\n                        }\n                    }\n\n                    o.position.x += o.speedMagnitude * o.speedUnit.x;\n                    o.position.y += o.speedMagnitude * o.speedUnit.y;\n\n                    // check for tile change\n                    this._engine.checkForTileChange(o);\n                    this._engine.checkForFollowCharacter(o);\n\n                    // check for direction change\n                }\n\n                // will need a different loop to process crashes\n                // for (i=0; i < len; i++)\n                // {\n                // o = this._movables[i];\n                // }\n            }\n\n            if (this._activeForTweens) {\n                // and a loop for tween animations\n                len = this._tweenTargets.length;\n                let t: ITween,\n                    tt: ITweenTarget,\n                    tweens: ITween[],\n                    j: number,\n                    vars: { [key: string]: { b: number; c: number } };\n                for (i = 0; i < len; i++) {\n                    tt = this._tweenTargets[i];\n                    tweens = tt.tweens;\n                    for (j = 0; j < tweens.length; j++) {\n                        t = tweens[j];\n                        t.currentFrame++;\n                        vars = t.vars;\n                        for (const prop in vars) {\n                            tt[prop] = t.easingFunc(t.currentFrame, vars[prop].b, vars[prop].c, t.totalFrames);\n                        }\n\n                        if (t.currentFrame >= t.totalFrames) {\n                            if (t.onComplete) {\n                                t.onComplete();\n                            }\n                            if (this.removeTween(tt, t)) {\n                                i--;\n                                len--;\n                            }\n                            j--;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Clears all references and stops all animations and tweens.\n     *\n     * @method\n     * @function\n     * @public\n     */\n    public destroy(): void {\n        trace('MoveEngine destroy');\n\n        this._processFrame = false;\n\n        if (this._ticker) {\n            this._ticker.stop();\n        }\n\n        this.removeAllMovables();\n        this.removeAllTweens();\n        this._movables = null;\n        this._tweenTargets = null;\n        this._engine = null;\n        this._ticker = null;\n    }\n}\n","import { Container, AnimatedSprite } from 'pixi.js';\nimport { EngineView } from './EngineView';\nimport { existy } from '../utils/calculations';\nimport { TDirection, DIRECTIONS } from '../utils/constants';\nimport {\n    TColumnRowPair,\n    ObjectInfoInteractionOffsets,\n    ObjectInfoTextures,\n    ObjectVisualKey,\n    getMovingDirVisualId,\n    getObjectInfo,\n    getStationaryDirVisualId,\n    IObjectInfo,\n} from '../utils/map';\n\n/**\n * Visual class for the map-objects.\n *\n * @class ObjectView\n * @extends PIXI.Container\n */\nexport class ObjectView extends Container {\n    /**\n     * A reference to the engine view that the map-object sits in.\n     * @property {EngineView} engine\n     * @private\n     * @internal\n     */\n    private _engine: EngineView;\n    /**\n     * Type-id of the map-object as defined in the json file.\n     * @property\n     * @public\n     */\n    private type: string;\n    /**\n     * Defines if the map-object is movable onto by other map-objects.\n     * @property\n     * @public\n     */\n    public isMovableTo: boolean;\n    /**\n     * Defines if the map-object is interactive/selectable.\n     * @property\n     * @public\n     */\n    public isInteractive: boolean;\n    /**\n     * Number of tiles that map-object covers horizontally on the isometric map\n     * @property\n     * @public\n     */\n    public columnSpan: number;\n    /**\n     * Number of tiles that map-object covers vertically on the isometric map\n     * @property\n     * @public\n     */\n    public rowSpan: number;\n\n    /**\n     * A dictionary for all the textures defined for the map-object.\n     * @property\n     * @private\n     */\n    private _textures: ObjectInfoTextures;\n\n    /**\n     * A dictionary for interaction offset points for each visual if defined in the map data file.\n     * @property\n     * @private\n     */\n    private _interactionOffsets: ObjectInfoInteractionOffsets;\n\n    /**\n     * If true doesn't allow transparency change on this object\n     * @property\n     * @public\n     */\n    public noTransparency: boolean;\n    /**\n     * Defines if the object is a floor object or not\n     * @property\n     * @public\n     */\n    public isFloorObject: boolean;\n    /**\n     * Interaction offset points for the active visual.\n     * @property\n     * @public\n     */\n    public currentInteractionOffset: TColumnRowPair;\n    /**\n     * Current direction of the object.\n     * @property\n     * @public\n     */\n    public currentDirection: TDirection;\n\n    /**\n     * Defines if the map-object is movable onto by other map-objects.\n     * @property\n     * @private\n     * @internal\n     */\n    private _container: AnimatedSprite;\n    /**\n     * Position of the object in terms of column and row index.\n     * @property\n     * @public\n     */\n    public mapPos: TColumnRowPair;\n\n    /**\n     * @property\n     * @function\n     * @private\n     * @internal\n     */\n    private onContainerAnimCompleteCallback: (objectView: ObjectView) => unknown;\n    /**\n     * @property\n     * @function\n     * @private\n     * @internal\n     */\n    private onContainerAnimComplete_delayed_binded: () => void;\n    /**\n     * @property\n     * @function\n     * @private\n     * @internal\n     */\n    private onContainerAnimComplete_binded: () => void;\n\n    /**\n     * Visual class constructor for the map-objects.\n     *\n     * @constructor\n     *\n     * @param engine {EngineView} the engine instance that the map-object sits in, required\n     * @param type {number} type-id of the object as defined in the JSON file\n     * @param animSpeed {number} animation speed for the animated visuals, default 0.5\n     */\n    constructor(engine: EngineView, type: string, animSpeed: number = 0.5) {\n        super();\n\n        this.onContainerAnimComplete_delayed_binded = this.onContainerAnimComplete_delayed.bind(this);\n        this.onContainerAnimComplete_binded = this.onContainerAnimComplete.bind(this);\n\n        this._engine = engine;\n        this.type = type;\n\n        const info: IObjectInfo = getObjectInfo(this._engine, this.type);\n        this.isMovableTo = info.m;\n        this.isInteractive = info.i;\n        this.interactive = this.interactiveChildren = false;\n        this.isFloorObject = info.f;\n        this.noTransparency = info.nt;\n        this.rowSpan = info.rowSpan;\n        this.columnSpan = info.columnSpan;\n        const xAnchor = this.rowSpan / (this.columnSpan + this.rowSpan);\n        this._textures = info.t;\n        this._interactionOffsets = info.io;\n        this.currentInteractionOffset = this._interactionOffsets.idle;\n\n        this._container = new AnimatedSprite(this._textures.idle);\n        this._container.interactive = this._container.interactiveChildren = false;\n        this._container.anchor.x = xAnchor;\n        this._container.anchor.y = 1;\n        this.addChild(this._container);\n        this.animSpeed = animSpeed;\n        this._container.gotoAndStop(0);\n    }\n\n    /**\n     * Animation speed for the animated visuals included in the map-object visuals.\n     *\n     * @property\n     * @default 0.5\n     */\n    public get animSpeed(): number {\n        return this._container.animationSpeed;\n    }\n    public set animSpeed(value: number) {\n        this._container.animationSpeed = existy(value) && value > 0 ? value : 0.5;\n    }\n\n    /**\n     * Changes the map-object's texture(s) according to the specified direction-id and the state of the map-object (moving or stationary).\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param direction {TDirection} direction-id as defined in `TRAVISO.DIRECTIONS`\n     * @param moving {boolean} if the requested visuals are for moving or stationary state, default `false`\n     * @param stopOnFirstFrame {boolean} if true stops on the first frame after changing the visuals, default `false`\n     * @param noLoop {boolean} if true the animation will not loop after the first run, default `false`\n     * @param onAnimComplete {Function} callback function to call if 'noLoop' is true after the first run of the animation, default `null`\n     * @param animSpeed {number} animation speed for the animated visuals, stays the same if not defined, default `null`\n     */\n    public changeVisualToDirection(\n        direction: TDirection,\n        moving: boolean = false,\n        stopOnFirstFrame: boolean = false,\n        noLoop: boolean = false,\n        onAnimComplete: (objectView: ObjectView) => unknown = null,\n        animSpeed: number = null\n    ): void {\n        if (\n            !this.changeVisual(\n                moving ? getMovingDirVisualId(direction) : getStationaryDirVisualId(direction),\n                stopOnFirstFrame,\n                noLoop,\n                onAnimComplete,\n                animSpeed\n            )\n        ) {\n            if (!this.changeVisual('idle', stopOnFirstFrame, noLoop, onAnimComplete, animSpeed)) {\n                throw new Error(\"no 'idle' visual defined as backup for object type \" + this.type);\n            } else {\n                this.currentDirection = DIRECTIONS.O;\n            }\n        } else {\n            this.currentDirection = direction;\n        }\n    }\n\n    /**\n     * Changes the map-object's texture(s) according to the specified visual-id.\n     *\n     * @method\n     * @function\n     * @public\n     * @internal\n     *\n     * @param vId {string} visual-id\n     * @param stopOnFirstFrame {boolean} if true stops on the first frame after changing the visuals, default `false`\n     * @param noLoop {boolean} if true the animation will not loop after the first run, default `false`\n     * @param onAnimComplete {Function} callback function to call if 'noLoop' is true after the first run of the animation, default `null`\n     * @param animSpeed {number} animation speed for the animated visuals, stays the same if not defined, default `null`\n     * @return {boolean} `true` if the visual-id was valid and the visual has changed without errors\n     */\n    public changeVisual(\n        vId: ObjectVisualKey,\n        stopOnFirstFrame: boolean = false,\n        noLoop: boolean = false,\n        onAnimComplete: (objectView: ObjectView) => unknown = null,\n        animSpeed: number = null\n    ): boolean {\n        if (!this._textures[vId]) {\n            // trace(\"!!! No textures defined for vId: \" + vId);\n            return false;\n        }\n\n        this.currentInteractionOffset = this._interactionOffsets[vId];\n\n        if (this._container.textures === this._textures[vId] && !noLoop) {\n            this._container.loop = !noLoop;\n            if (existy(animSpeed) && animSpeed > 0) {\n                this.animSpeed = animSpeed;\n            }\n            return true;\n        }\n\n        this._container.textures = this._textures[vId];\n\n        if (!stopOnFirstFrame && this._textures[vId].length > 1) {\n            this._container.loop = !noLoop;\n            if (noLoop && onAnimComplete) {\n                this.onContainerAnimCompleteCallback = onAnimComplete;\n                this._container.onComplete = this.onContainerAnimComplete_binded;\n            }\n            if (existy(animSpeed) && animSpeed > 0) {\n                this.animSpeed = animSpeed;\n            }\n            this._container.gotoAndPlay(0);\n        } else {\n            this._container.gotoAndStop(0);\n        }\n\n        if (this._engine.objectUpdateCallback) {\n            this._engine.objectUpdateCallback(this);\n        }\n\n        return true;\n    }\n\n    private onContainerAnimComplete(): void {\n        setTimeout(this.onContainerAnimComplete_delayed_binded, 100);\n    }\n    private onContainerAnimComplete_delayed(): void {\n        this.onContainerAnimCompleteCallback(this);\n        this.onContainerAnimCompleteCallback = null;\n    }\n\n    /**\n     * Clears all references.\n     *\n     * @method\n     * @function\n     * @public\n     */\n    public destroy(): void {\n        if (this._container) {\n            this._engine = null;\n            this._textures = null;\n            // this.removeChild(this._container);\n            // this._container.textures = null;\n            this._container.onComplete = null;\n            this._container = null;\n        }\n    }\n}\n","import { Texture, Container, Graphics, Sprite, AnimatedSprite } from 'pixi.js';\nimport { EngineView } from './EngineView';\nimport { TColumnRowPair, getTileInfo } from '../utils/map';\nimport { ITweenTarget } from './MoveEngine';\n\n/**\n * Visual class for the map-tiles.\n *\n * @class TileView\n * @extends PIXI.Container\n * @constructor\n * @param engine {EngineView} the engine instance that the map-tile sits in\n * @param type {string} type-id of the tile as defined in the JSON file\n */\nexport class TileView extends Container {\n    /**\n     * A reference to the engine view that the map-tile sits in.\n     * @property\n     * @private\n     * @internal\n     */\n    private _engine: EngineView;\n    /**\n     * Type-id of the map-tile as defined in the JSON file.\n     * @property\n     * @public\n     */\n    public type: string;\n    /**\n     * Defines the positions of the vertices of the tile.\n     * @property\n     * @public\n     */\n    public vertices: number[][];\n    /**\n     * Defines if the map-tile is movable onto by map-objects.\n     * @property\n     * @public\n     */\n    public isMovableTo: boolean;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private _tileGraphics: AnimatedSprite;\n    /**\n     * The visual that will be used to highlight the tile.\n     * @property\n     * @private\n     * @internal\n     */\n    private _highlightedOverlay: Sprite | Graphics;\n    /**\n     * The highlight state of the map-tile.\n     * @property\n     * @private\n     * @internal\n     */\n    private _isHighlighted: boolean = false;\n    /**\n     * Position of the tile in terms of column and row index.\n     * @property\n     * @public\n     */\n    public mapPos: TColumnRowPair;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private onHighlightTweenEnd_binded: () => void;\n\n    /**\n     * Visual class constructor for the map-tiles.\n     *\n     * @constructor\n     *\n     * @param engine {EngineView} the engine instance that the map-tile sits in\n     * @param type {string} type-id of the tile as defined in the JSON file\n     */\n    constructor(engine: EngineView, type: string) {\n        super();\n\n        this.onHighlightTweenEnd_binded = this.onHighlightTweenEnd.bind(this);\n\n        this._engine = engine;\n        this.type = type;\n\n        const halfHeight = this._engine.tileHalfHeight;\n        const halfWidth = this._engine.tileHalfWidth;\n\n        this.vertices = [\n            [-halfWidth, 0],\n            [0, -halfHeight],\n            [halfWidth, 0],\n            [0, halfHeight],\n        ];\n\n        const tileInfo = getTileInfo(this._engine, this.type);\n        this.isMovableTo = tileInfo.m;\n\n        if (tileInfo.t.length > 0) {\n            this._tileGraphics = new AnimatedSprite(tileInfo.t);\n            this._tileGraphics.anchor.x = 0.5;\n            this._tileGraphics.anchor.y = 0.5;\n            this.addChild(this._tileGraphics);\n            this._tileGraphics.gotoAndStop(parseInt(this.type));\n        }\n\n        // const colorsArray = [0x0106ff, 0x3b6d14, 0x8789ff, 0xb32bf9, 0xeb36d0, 0xfe0000, 0xeb3647, 0xf27e31, 0xffea01, 0x00ff18, 0x3b6d14, 0xfa9bbb, 0xf9c7bc, 0x8d6729, 0x633e07];\n        // const c = colorsArray[ this.type < 2 ? this.type : 0 ];\n\n        // this._tileGraphics = new PIXI.Graphics();\n        // this._tileGraphics.clear();\n        // this._tileGraphics.beginFill(c);\n        // this._tileGraphics.moveTo(this.vertices[0][0], this.vertices[0][1]);\n        // for (let i=1; i < this.vertices.length; i++)\n        // {\n        // this._tileGraphics.lineTo(this.vertices[i][0], this.vertices[i][1]);\n        // };\n        // this._tileGraphics.endFill();\n\n        if (this._engine.mapData.tileHighlightImage) {\n            this._highlightedOverlay = new Sprite(Texture.from(this._engine.mapData.tileHighlightImage.path));\n            this._highlightedOverlay.anchor.x = 0.5;\n            this._highlightedOverlay.anchor.y = 0.5;\n            this.addChild(this._highlightedOverlay);\n        } else {\n            this._highlightedOverlay = new Graphics();\n            this._highlightedOverlay.clear();\n            this._highlightedOverlay.lineStyle(\n                this._engine.tileHighlightStrokeAlpha <= 0 ? 0 : 2,\n                this._engine.tileHighlightStrokeColor,\n                this._engine.tileHighlightStrokeAlpha\n            );\n            this._highlightedOverlay.beginFill(\n                this._engine.tileHighlightFillColor,\n                this._engine.tileHighlightFillAlpha\n            );\n            this._highlightedOverlay.moveTo(this.vertices[0][0], this.vertices[0][1]);\n            for (let i = 1; i < this.vertices.length; i++) {\n                this._highlightedOverlay.lineTo(this.vertices[i][0], this.vertices[i][1]);\n            }\n            this._highlightedOverlay.lineTo(this.vertices[0][0], this.vertices[0][1]);\n            this._highlightedOverlay.endFill();\n            this.addChild(this._highlightedOverlay);\n        }\n\n        this._highlightedOverlay.scale.x = this._highlightedOverlay.scale.y = 0.1;\n        this._highlightedOverlay.visible = false;\n    }\n\n    /**\n     * Changes the highlight state of the map-tile.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param isHighlighted {boolean} if the tile is being highlighted or not\n     * @param instant {boolean} if the change will be instant or animated, default `false`\n     */\n    public setHighlighted(isHighlighted: boolean, instant: boolean = false): void {\n        if (this._isHighlighted !== isHighlighted) {\n            if (instant) {\n                this._highlightedOverlay.scale.x = this._highlightedOverlay.scale.y = isHighlighted ? 1 : 0.1;\n                this._highlightedOverlay.visible = isHighlighted;\n                this._isHighlighted = isHighlighted;\n                return;\n            }\n\n            if (isHighlighted) {\n                this._highlightedOverlay.visible = isHighlighted;\n            }\n\n            this._isHighlighted = isHighlighted;\n\n            const ts = isHighlighted ? 1 : 0.1;\n            if (this._highlightedOverlay.scale.x === ts) {\n                this._highlightedOverlay.visible = isHighlighted;\n            } else {\n                this._highlightedOverlay.scale.x = this._highlightedOverlay.scale.y = isHighlighted ? 0.1 : 1;\n\n                // @formatter:off\n                this._engine.moveEngine.addTween(\n                    this._highlightedOverlay.scale as unknown as ITweenTarget,\n                    0.5,\n                    { x: ts, y: ts },\n                    0,\n                    'linear',\n                    true,\n                    this.onHighlightTweenEnd_binded\n                );\n                // @formatter:on\n            }\n        }\n    }\n    /**\n     * @method\n     * @function\n     * @private\n     * @internal\n     */\n    private onHighlightTweenEnd(): void {\n        this._highlightedOverlay.visible = this._isHighlighted;\n    }\n\n    /**\n     * Clears all references.\n     *\n     * @method\n     * @function\n     * @public\n     */\n    public destroy(): void {\n        if (this._engine) {\n            if (this._engine && this._engine.moveEngine) {\n                this._engine.moveEngine.killTweensOf(this._highlightedOverlay.scale as unknown as ITweenTarget);\n            }\n            this._engine = null;\n            this._highlightedOverlay = null;\n            this._tileGraphics = null;\n        }\n    }\n}\n","import {\n    Container,\n    DisplayObject,\n    Graphics,\n    InteractionData,\n    InteractionEvent,\n    Loader,\n    Sprite,\n    Texture,\n} from 'pixi.js';\nimport { GridNode } from '../pathFinding/GridNode';\nimport { PathFinding } from '../pathFinding/PathFinding';\nimport { existy, getDist, isInPolygon, mathMap } from '../utils/calculations';\nimport { KEY_EMPTY_TILE, KEY_NO_OBJECTS, PF_ALGORITHMS } from '../utils/constants';\nimport {\n    getDirBetween,\n    IMapDataObject,\n    MapDataObjectVisual,\n    ObjectInfoInteractionOffsets,\n    ObjectInfoTextureNames,\n    ObjectVisualKey,\n    TColumnRowPair,\n    TMapData,\n    TPositionPair,\n} from '../utils/map';\nimport { trace } from '../utils/trace';\nimport { IMovable, ITweenTarget, MoveEngine } from './MoveEngine';\nimport { ObjectView } from './ObjectView';\nimport { TileView } from './TileView';\n\n/**\n * Type declaration for position frame setting.\n */\nexport type TPositionFrame = {\n    /** x position of the frame */\n    x: number;\n    /** y position of the frame */\n    y: number;\n    /** width of the frame */\n    w: number;\n    /** height of the frame */\n    h: number;\n};\n/**\n * Type declaration for engine-specific configuration.\n */\nexport type TEngineConfiguration = {\n    /**\n     * minimum scale that the PIXI.Container for the map can get, default 0.5\n     * @default 0.5\n     */\n    minScale?: number;\n    /**\n     * maximum scale that the PIXI.Container for the map can get, default 1.5\n     * @default 1.5\n     */\n    maxScale?: number;\n    /** minimum zoom level, engine defined  */\n    minZoom?: number;\n    /** maximum zoom level, engine defined  */\n    maxZoom?: number;\n    /**\n     * zoom increment amount calculated by the engine according to user settings, default 0.5\n     * @default 0.5\n     */\n    zoomIncrement?: number;\n    /**\n     * used to calculate zoom increment, defined by user, default 5\n     * @default 5\n     */\n    numberOfZoomLevels?: number;\n    /**\n     * initial zoom level of the map, default 0\n     * @default 0\n     */\n    initialZoomLevel?: number;\n    /**\n     * specifies whether to zoom instantly or with a tween animation, default false\n     * @default false\n     */\n    instantCameraZoom?: boolean;\n\n    /**\n     * height of a single isometric tile, default 74\n     * @default 74\n     */\n    tileHeight?: number;\n    /**\n     * the angle between the top-left edge and the horizontal diagonal of a isometric quad, default 30\n     * @default 30\n     */\n    isoAngle?: number;\n\n    /**\n     * frame to position the engine, default `{ x : 0, y : 0, w : 800, h : 600 }`\n     * @default { x : 0, y : 0, w : 800, h : 600 }\n     */\n    initialPositionFrame?: TPositionFrame;\n\n    /**\n     * the type of path finding algorithm two use, default `TRAVISO.PF_ALGORITHMS.ASTAR_ORTHOGONAL`\n     * @default TRAVISO.PF_ALGORITHMS.ASTAR_ORTHOGONAL\n     */\n    pathFindingType?: number;\n    /**\n     * whether to return the path to the closest node if the target is unreachable, default false\n     * @default false\n     */\n    pathFindingClosest?: boolean;\n\n    /**\n     * defines if the camera will follow the current controllable or not, default true\n     * @default true\n     */\n    followCharacter?: boolean;\n    /**\n     * specifies whether the camera moves instantly or with a tween animation to the target location, default false\n     * @default false\n     */\n    instantCameraRelocation?: boolean;\n    /**\n     * specifies whether the map-objects will be moved to target location instantly or with an animation, default false\n     * @default false\n     */\n    instantObjectRelocation?: boolean;\n\n    /**\n     * Make objects transparent when the controllable is behind them, default true\n     * @default true\n     */\n    changeTransparencies?: boolean;\n\n    /**\n     * Highlight the path when the current controllable moves on the map, default true\n     * @default true\n     */\n    highlightPath?: boolean;\n    /**\n     * Highlight the target tile when the current controllable moves on the map, default true\n     * @default true\n     */\n    highlightTargetTile?: boolean;\n    /**\n     * Animate the tile highlights, default true\n     * @default true\n     */\n    tileHighlightAnimated?: boolean;\n    /**\n     * Color code for the tile highlight fill (this will be overridden if a highlight-image is defined), default 0x80d7ff\n     * @default 0x80d7ff\n     */\n    tileHighlightFillColor?: number;\n    /**\n     * Alpha value for the tile highlight fill (this will be overridden if a highlight-image is defined), default 0.5\n     * @default 0.5\n     */\n    tileHighlightFillAlpha?: number;\n    /**\n     * Color code for the tile highlight stroke (this will be overridden if a highlight-image is defined), default 0xFFFFFF\n     * @default 0xFFFFFF\n     */\n    tileHighlightStrokeColor?: number;\n    /**\n     * Alpha value for the tile highlight stroke (this will be overridden if a highlight-image is defined), default 1.0\n     * @default 1.0\n     */\n    tileHighlightStrokeAlpha?: number;\n    /**\n     * When a tile selected don't move the controllable immediately but still call 'tileSelectCallback', default false\n     * @default false\n     */\n    dontAutoMoveToTile?: boolean;\n    /**\n     * Looks for a path every time an object moves to a new tile (set to false if you don't have other moving objects on your map), default true\n     * @default true\n     */\n    checkPathOnEachTile?: boolean;\n\n    /**\n     * Enable dragging the map with touch-and-touchmove or mousedown-and-mousemove on the map, default true\n     * @default true\n     */\n    mapDraggable?: boolean;\n\n    /**\n     * Background color, if defined the engine will create a solid colored background for the map, default null\n     * @default null\n     */\n    backgroundColor?: number;\n    /**\n     * Creates a mask using the position frame defined by 'initialPositionFrame' property or the 'posFrame' parameter that is passed to 'repositionContent' method, default false\n     * @default false\n     */\n    useMask?: boolean;\n\n    /** The path to the json file that defines map data, required */\n    mapDataPath: string;\n    /**\n     * Array of paths to the assets that are desired to be loaded by traviso, no need to use if assets are already loaded to PIXI cache, default null\n     * @default null\n     */\n    assetsToLoad?: string[];\n\n    /**\n     * Callback function that will be called once everything is loaded and engine instance is ready, default null\n     * @default null\n     */\n    engineInstanceReadyCallback?: (engineInstance: EngineView) => unknown;\n    /**\n     * Callback function that will be called when a tile is selected (call params will be the row and column indexes of the tile selected), default null\n     * @default null\n     */\n    tileSelectCallback?: (r: number, c: number) => unknown;\n    /**\n     * Callback function that will be called when a tile with an interactive map-object on it is selected (call param will be the object selected), default null\n     * @default null\n     */\n    objectSelectCallback?: (objectView: ObjectView) => unknown;\n    /**\n     * Callback function that will be called when any moving object reaches its destination (call param will be the moving object itself), default null\n     * @default null\n     */\n    objectReachedDestinationCallback?: (objectView: ObjectView) => unknown;\n    /**\n     * Callback function that will be called when any moving object is in move and there are other objects on the next tile, default null\n     * @default null\n     */\n    otherObjectsOnTheNextTileCallback?: (objectView: ObjectView, otherObjectViews: ObjectView[]) => unknown;\n    /**\n     * Callback function that will be called every time an objects direction or position changed, default null\n     * @default null\n     */\n    objectUpdateCallback?: (objectView: ObjectView) => unknown;\n};\n\n/**\n * Main PIXI.Container class to hold all views within the engine and all map related logic.\n *\n * @class EngineView\n * @extends PIXI.Container\n */\nexport class EngineView extends Container {\n    /**\n     * Internal property holding the engine configuration.\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _config: TEngineConfiguration;\n\n    /**\n     * The default height of a single isometric tile\n     *\n     * @default 74\n     * @property\n     * @private\n     * @static\n     */\n    private static readonly DEFAULT_TILE_H: number = 74;\n\n    /**\n     * The default angle (in degrees) between the top-left edge and the horizontal diagonal of a isometric quad\n     *\n     * @default 30\n     * @property\n     * @private\n     * @static\n     */\n    private static readonly DEFAULT_ISO_ANGLE: number = 30;\n\n    /**\n     * Half-height of a single isometric tile\n     *\n     * @default 37\n     * @property\n     * @public\n     */\n    public readonly tileHalfHeight: number;\n\n    /**\n     * Half-width of a single isometric tile\n     *\n     * @default 64\n     * @property\n     * @public\n     */\n    public readonly tileHalfWidth: number;\n\n    /**\n     * Variable holding the parsed and processed map data\n     *\n     * @property\n     * @public\n     */\n    public mapData: TMapData;\n\n    /**\n     * MoveEngine instance to handle all animations and tweens\n     *\n     * @property\n     * @public\n     */\n    public moveEngine: MoveEngine;\n    /**\n     * Current scale of the map's display object\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _currentScale: number;\n    /**\n     * Current zoom amount of the map\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _currentZoom: number;\n    /**\n     * Active position frame for the engine.\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _posFrame: TPositionFrame = { x: 0, y: 0, w: 800, h: 600 };\n    /**\n     * Active external center point for the engine.\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _externalCenter: TPositionPair;\n\n    /**\n     * Solid colored background\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _bg: Graphics;\n    /**\n     * Mask graphics for the mask\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _mapMask: Graphics;\n    /**\n     * Display object for the map visuals\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _mapContainer: Container;\n    /**\n     * Display object for the ground/terrain visuals\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _groundContainer: Container;\n    /**\n     * Display object for the map-object visuals\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _objContainer: Container;\n    /**\n     * Number of rows in the isometric map\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _mapSizeR: number;\n    /**\n     * Number of columns in the isometric map\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _mapSizeC: number;\n    /**\n     * Array to hold map-tiles\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _tileArray: TileView[][];\n    /**\n     * Array to hold map-objects\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _objArray: ObjectView[][][];\n    /**\n     * PathFinding instance to handle all path finding logic\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _pathFinding: PathFinding;\n    /**\n     * Current controllable map-object that will be the default object to move in user interactions\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _currentControllable: ObjectView;\n    /**\n     * Vertices of the map\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _mapVertices: number[][];\n    /**\n     * Total width of all ground tiles\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _mapVisualWidthReal: number;\n    /**\n     * Total height of all ground tiles\n     *\n     * @property\n     * @private\n     * @internal\n     */\n    private _mapVisualHeightReal: number;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private _currentFocusLocation: TColumnRowPair;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private _mapVisualWidthScaled: number;\n    /**\n     * @default `false`\n     * @property\n     * @private\n     * @internal\n     */\n    private _dragging: boolean = false;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private _dragInitStartingX: number;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private _dragInitStartingY: number;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private _dragPrevStartingX: number;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private _dragPrevStartingY: number;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private onMouseUp_binded: (event: InteractionEvent) => void;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private onMouseDown_binded: (event: InteractionEvent) => void;\n    /**\n     * @property\n     * @private\n     * @internal\n     */\n    private onMouseMove_binded: (event: InteractionEvent) => void;\n\n    /**\n     * Constructor method for the main PIXI.Container class to hold all views within the engine and all map related logic.\n     *\n     * @constructor\n     * @param config {TEngineConfiguration} configuration object for the isometric engine instance\n     */\n    constructor(config: TEngineConfiguration) {\n        super();\n\n        this.onMouseUp_binded = this.onMouseUp.bind(this);\n        this.onMouseDown_binded = this.onMouseDown.bind(this);\n        this.onMouseMove_binded = this.onMouseMove.bind(this);\n\n        this._config = config;\n\n        // set the properties that are set by default when not defined by the user\n        this._config.followCharacter = existy(this._config.followCharacter) ? this._config.followCharacter : true;\n        this._config.changeTransparencies = existy(this._config.changeTransparencies)\n            ? this._config.changeTransparencies\n            : true;\n        this._config.highlightPath = existy(this._config.highlightPath) ? this._config.highlightPath : true;\n        this._config.highlightTargetTile = existy(this._config.highlightTargetTile)\n            ? this._config.highlightTargetTile\n            : true;\n        this._config.tileHighlightAnimated = existy(this._config.tileHighlightAnimated)\n            ? this._config.tileHighlightAnimated\n            : true;\n        this._config.tileHighlightFillColor = existy(this._config.tileHighlightFillColor)\n            ? this._config.tileHighlightFillColor\n            : 0x80d7ff;\n        this._config.tileHighlightFillAlpha = existy(this._config.tileHighlightFillAlpha)\n            ? this._config.tileHighlightFillAlpha\n            : 0.5;\n        this._config.tileHighlightStrokeColor = existy(this._config.tileHighlightStrokeColor)\n            ? this._config.tileHighlightStrokeColor\n            : 0xffffff;\n        this._config.tileHighlightStrokeAlpha = existy(this._config.tileHighlightStrokeAlpha)\n            ? this._config.tileHighlightStrokeAlpha\n            : 1.0;\n        this._config.dontAutoMoveToTile = existy(this._config.dontAutoMoveToTile)\n            ? this._config.dontAutoMoveToTile\n            : false;\n        this._config.checkPathOnEachTile = existy(this._config.checkPathOnEachTile)\n            ? this._config.checkPathOnEachTile\n            : true;\n        this._config.mapDraggable = existy(this._config.mapDraggable) ? this._config.mapDraggable : true;\n        this._config.isoAngle = existy(this._config.isoAngle) ? this._config.isoAngle : EngineView.DEFAULT_ISO_ANGLE;\n        this._config.tileHeight = existy(this._config.tileHeight) ? this._config.tileHeight : EngineView.DEFAULT_TILE_H;\n\n        this.setZoomParameters(\n            this._config.minScale,\n            this._config.maxScale,\n            this._config.numberOfZoomLevels,\n            this._config.initialZoomLevel,\n            this._config.instantCameraZoom\n        );\n\n        this.tileHalfHeight = this._config.tileHeight / 2;\n        this.tileHalfWidth = this.tileHalfHeight * Math.tan(((90 - this._config.isoAngle) * Math.PI) / 180);\n        // this.TILE_W = this.tileHalfWidth * 2;\n\n        this.loadAssetsAndData();\n    }\n\n    /**\n     * Handles loading of necessary assets and map data for the given engine instance.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     */\n    private loadAssetsAndData(): void {\n        if (!this._config.mapDataPath) {\n            throw new Error(\n                \"TRAVISO: No JSON-file path defined for map data. Please check your configuration object that you pass to the 'getEngineInstance' method.\"\n            );\n        } else if (this._config.mapDataPath.split('.').pop() !== 'json') {\n            throw new Error('TRAVISO: Invalid map-data file path. This file has to be a json file.');\n        }\n\n        const loader = new Loader();\n        loader.add('mapData', this._config.mapDataPath, { crossOrigin: true });\n\n        if (this._config.assetsToLoad && this._config.assetsToLoad.length > 0) {\n            loader.add(this._config.assetsToLoad);\n        }\n\n        loader.load(this.assetsAndDataLoaded.bind(this));\n\n        // TRAVISO.loadData();\n    }\n\n    /**\n     * Handles loading of map data for the given engine instance.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param loader {Loader} PIXI's loader instance\n     */\n    private assetsAndDataLoaded(loader: Loader): void {\n        // console.log('assetsAndDataLoaded', resources.mapData.data);\n\n        const mapData: TMapData = loader.resources.mapData.data as TMapData;\n\n        // initial controls\n\n        if (!existy(mapData.initialControllableLocation)) {\n            trace(\n                \"Map-data file warning: No 'initialControllableLocation' defined. Ignore this warning if you are adding it later manually.\"\n            );\n        } else if (\n            !existy(mapData.initialControllableLocation.columnIndex) ||\n            !existy(mapData.initialControllableLocation.rowIndex)\n        ) {\n            trace(\"Map-data file warning: 'initialControllableLocation' exists but it is not defined properly.\");\n            mapData.initialControllableLocation = null;\n        }\n\n        if (mapData.tileHighlightImage && !mapData.tileHighlightImage.path) {\n            trace(\"Map-data file warning: 'tileHighlightImage' exists but its 'path' is not defined properly.\");\n            mapData.tileHighlightImage = null;\n        }\n\n        if (mapData.singleGroundImage && !mapData.singleGroundImage.path) {\n            trace(\"Map-data file warning: 'singleGroundImage' exists but its 'path' is not defined properly.\");\n            mapData.singleGroundImage = null;\n        }\n\n        let i: number, j: number, arr: string[];\n        let rows = mapData.groundMap;\n        mapData.groundMapData = [];\n        for (i = 0; i < rows.length; i++) {\n            arr = String(rows[i].row).replace(/\\s/g, '').split(',');\n            // remove empty spaces in a row and cast to an array\n            for (j = arr.length; j--; ) {\n                arr[j] = arr[j] || KEY_EMPTY_TILE;\n            }\n            mapData.groundMapData[i] = arr;\n        }\n\n        rows = mapData.objectsMap;\n        mapData.objectsMapData = [];\n        for (i = 0; i < rows.length; i++) {\n            arr = String(rows[i].row).replace(/\\s/g, '').split(',');\n            // remove empty spaces in a row and cast to an array\n            for (j = arr.length; j--; ) {\n                arr[j] = arr[j] || KEY_NO_OBJECTS;\n            }\n            mapData.objectsMapData[i] = arr;\n        }\n\n        if (!existy(mapData.tiles)) {\n            trace(\"Map-data file warning: No 'tiles' defined.\");\n            mapData.tiles = {};\n        }\n        if (!existy(mapData.objects)) {\n            trace(\"Map-data file warning: No 'objects' defined.\");\n            mapData.objects = {};\n        }\n\n        let obj: IMapDataObject,\n            objId: string,\n            visual: MapDataObjectVisual,\n            visualId: ObjectVisualKey,\n            interactionOffsets: ObjectInfoInteractionOffsets,\n            oTextures: ObjectInfoTextureNames,\n            m: number,\n            n: number;\n        for (objId in mapData.objects) {\n            obj = mapData.objects[objId];\n            if (!existy(obj.visuals)) {\n                throw new Error('TRAVISO: No visuals defined in data-file for object type: ' + objId);\n            }\n            obj.id = objId;\n            if (!existy(obj.rowSpan)) {\n                obj.rowSpan = 1;\n            }\n            if (!existy(obj.columnSpan)) {\n                obj.columnSpan = 1;\n            }\n\n            oTextures = {};\n            interactionOffsets = {};\n\n            for (visualId in obj.visuals) {\n                visual = obj.visuals[visualId];\n\n                if (existy(visual.ipor) && existy(visual.ipoc)) {\n                    interactionOffsets[visualId] = {\n                        c: Number(visual.ipoc),\n                        r: Number(visual.ipor),\n                    };\n                }\n\n                // visual = (visual  as MapDataObjectVisualType1);\n                if (visual.frames && visual.frames.length > 0) {\n                    oTextures[visualId] = [];\n                    for (m = 0; m < visual.frames.length; m++) {\n                        oTextures[visualId][m] = visual.frames[m].path;\n                    }\n                } else {\n                    if (!visual.path || !visual.extension || !visual.numberOfFrames || visual.numberOfFrames < 1) {\n                        throw new Error(\n                            'TRAVISO: Invalid or missing visual attributes detected in data-file for visual with id: ' +\n                                visualId\n                        );\n                    }\n\n                    oTextures[visualId] = [];\n                    if (visual.numberOfFrames === 1) {\n                        oTextures[visualId][0] = visual.path + '.' + visual.extension;\n                    } else {\n                        n = 0;\n                        for (m = visual.startIndex; m < visual.numberOfFrames; m++) {\n                            oTextures[visualId][n++] = visual.path + String(m) + '.' + visual.extension;\n                        }\n                    }\n                }\n            }\n\n            obj.textureNames = oTextures;\n            obj.io = interactionOffsets;\n            obj.f = !!obj.floor;\n            obj.nt = !!obj.noTransparency;\n            obj.m = !!obj.movable;\n            obj.i = !!obj.interactive;\n        }\n\n        delete mapData.objectsMap;\n        delete mapData.groundMap;\n\n        this.mapData = mapData;\n\n        this.onAllAssetsLoaded();\n    }\n\n    /**\n     * This method is being called whenever all the assets are\n     * loaded and engine is ready to initialize.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     */\n    private onAllAssetsLoaded(): void {\n        trace('All assets loaded');\n\n        this.moveEngine = new MoveEngine(this);\n\n        this._currentScale = 1.0;\n        this._currentZoom = 0;\n\n        this._posFrame = this._config.initialPositionFrame || {\n            x: 0,\n            y: 0,\n            w: 800,\n            h: 600,\n        };\n\n        this._externalCenter = {\n            x: this._posFrame.w >> 1,\n            y: this._posFrame.h >> 1,\n        };\n\n        this.createMap();\n\n        this.repositionContent(this._config.initialPositionFrame);\n\n        this.enableInteraction();\n\n        if (this._config.engineInstanceReadyCallback) {\n            this._config.engineInstanceReadyCallback(this);\n        }\n    }\n\n    /**\n     * Creates the map and setups necessary parameters for future map calculations.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     */\n    private createMap(): void {\n        // create background\n        if (this._config.backgroundColor) {\n            this._bg = new Graphics();\n            this.addChild(this._bg);\n        }\n\n        // create mask\n        if (this._config.useMask) {\n            this._mapMask = new Graphics();\n            this.addChild(this._mapMask);\n        }\n\n        // create containers for visual map elements\n        this._mapContainer = new Container();\n        this.addChild(this._mapContainer);\n\n        // Define two layers of maps\n        // One for the world and one for the objects (static/dynamic) over it\n        // This enables us not to update the whole world in every move but instead just update the object depths over it\n\n        this._groundContainer = new Container();\n        this._mapContainer.addChild(this._groundContainer);\n\n        this._objContainer = new Container();\n        this._mapContainer.addChild(this._objContainer);\n\n        const groundMapData = this.mapData.groundMapData;\n        const objectsMapData = this.mapData.objectsMapData;\n\n        const initialControllableLocation = this.mapData.initialControllableLocation;\n\n        // set map size\n        this._mapSizeR = groundMapData.length;\n        this._mapSizeC = groundMapData[0].length;\n\n        // add ground image first if it is defined\n        let groundImageSprite: Sprite;\n        if (this.mapData.singleGroundImage) {\n            groundImageSprite = new Sprite(Texture.from(this.mapData.singleGroundImage.path));\n            this._groundContainer.addChild(groundImageSprite);\n\n            groundImageSprite.scale.set(this.mapData.singleGroundImage.scale || 1);\n        }\n\n        // create arrays to hold tiles and objects\n        this._tileArray = [];\n        this._objArray = [];\n        let i, j;\n        for (i = 0; i < this._mapSizeR; i++) {\n            this._tileArray[i] = [];\n            this._objArray[i] = [];\n            for (j = 0; j < this._mapSizeC; j++) {\n                this._tileArray[i][j] = null;\n                this._objArray[i][j] = null;\n            }\n        }\n\n        // Map data is being sent to path finding and after this point\n        // its content will be different acc to the path-finding algorithm.\n        // It is still being stored in engine.mapData but you must be aware\n        // of the structure if you want to use it after this point.\n        this._pathFinding = new PathFinding(this._mapSizeC, this._mapSizeR, {\n            diagonal: this._config.pathFindingType === PF_ALGORITHMS.ASTAR_DIAGONAL,\n            closest: this._config.pathFindingClosest,\n        });\n\n        let tile;\n        for (i = 0; i < this._mapSizeR; i++) {\n            for (j = this._mapSizeC - 1; j >= 0; j--) {\n                this._tileArray[i][j] = null;\n                if (groundMapData[i][j] && groundMapData[i][j] !== KEY_EMPTY_TILE) {\n                    tile = new TileView(this, groundMapData[i][j]);\n                    tile.position.x = this.getTilePosXFor(i, j);\n                    tile.position.y = this.getTilePosYFor(i, j);\n                    tile.mapPos = { c: j, r: i };\n                    this._tileArray[i][j] = tile;\n                    this._groundContainer.addChild(tile);\n\n                    if (!tile.isMovableTo) {\n                        this._pathFinding.setCell(j, i, 0);\n                    }\n                } else {\n                    this._pathFinding.setCell(j, i, 0);\n                }\n            }\n        }\n\n        let obj,\n            floorObjectFound = false;\n        for (i = 0; i < this._mapSizeR; i++) {\n            for (j = this._mapSizeC - 1; j >= 0; j--) {\n                this._objArray[i][j] = null;\n                if (objectsMapData[i][j] && objectsMapData[i][j] !== KEY_NO_OBJECTS) {\n                    obj = new ObjectView(this, objectsMapData[i][j]);\n                    obj.position.x = this.getTilePosXFor(i, j);\n                    obj.position.y = this.getTilePosYFor(i, j) + this.tileHalfHeight;\n                    obj.mapPos = { c: j, r: i };\n\n                    if (!floorObjectFound && obj.isFloorObject) {\n                        floorObjectFound = true;\n                    }\n\n                    this._objContainer.addChild(obj);\n\n                    this.addObjRefToLocation(obj, obj.mapPos);\n\n                    // if (initialControllableLocation && initialControllableLocation.c === j && initialControllableLocation.r === i)\n                    if (\n                        initialControllableLocation &&\n                        initialControllableLocation.columnIndex === j &&\n                        initialControllableLocation.rowIndex === i\n                    ) {\n                        this._currentControllable = obj;\n                    }\n                }\n            }\n        }\n        if (floorObjectFound) {\n            // run the loop again to bring the other objects on top of the floor objects\n            let a, k;\n            for (i = 0; i < this._mapSizeR; i++) {\n                for (j = this._mapSizeC - 1; j >= 0; j--) {\n                    a = this._objArray[i][j];\n                    if (a) {\n                        for (k = 0; k < a.length; k++) {\n                            if (!a[k].isFloorObject) {\n                                this._objContainer.addChild(a[k]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // cacheAsBitmap: for now this creates problem with tile highlights\n        // this._groundContainer.cacheAsBitmap = true;\n\n        this._mapVertices = [\n            [this.getTilePosXFor(0, 0) - this.tileHalfWidth, this.getTilePosYFor(0, 0)],\n            [\n                this.getTilePosXFor(0, this._mapSizeC - 1),\n                this.getTilePosYFor(0, this._mapSizeC - 1) - this.tileHalfHeight,\n            ],\n            [\n                this.getTilePosXFor(this._mapSizeR - 1, this._mapSizeC - 1) + this.tileHalfWidth,\n                this.getTilePosYFor(this._mapSizeR - 1, this._mapSizeC - 1),\n            ],\n            [\n                this.getTilePosXFor(this._mapSizeR - 1, 0),\n                this.getTilePosYFor(this._mapSizeR - 1, 0) + this.tileHalfHeight,\n            ],\n        ];\n\n        this._mapVisualWidthReal =\n            this.getTilePosXFor(this._mapSizeR - 1, this._mapSizeC - 1) - this.getTilePosXFor(0, 0);\n        this._mapVisualHeightReal =\n            this.getTilePosYFor(this._mapSizeR - 1, 0) - this.getTilePosYFor(0, this._mapSizeC - 1);\n\n        if (groundImageSprite) {\n            groundImageSprite.position.x =\n                this._mapVertices[0][0] + this.tileHalfWidth + (this._mapVisualWidthReal - groundImageSprite.width) / 2;\n            groundImageSprite.position.y =\n                this._mapVertices[1][1] +\n                this.tileHalfHeight +\n                (this._mapVisualHeightReal - groundImageSprite.height) / 2;\n        }\n\n        this.zoomTo(this._config.initialZoomLevel, true);\n\n        if (this._config.followCharacter && initialControllableLocation) {\n            // this.centralizeToLocation(initialControllableLocation.c, initialControllableLocation.r, true);\n            this.centralizeToLocation(\n                initialControllableLocation.columnIndex,\n                initialControllableLocation.rowIndex,\n                true\n            );\n        } else {\n            this.centralizeToCurrentExternalCenter(true);\n        }\n    }\n\n    /**\n     * Calculates 2D X position of a tile, given its column and row indices.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param r {number} row index of the tile\n     * @param c {number} column index of the tile\n     * @return {number} 2D X position of a tile\n     */\n    public getTilePosXFor(r: number, c: number): number {\n        return c * this.tileHalfWidth + r * this.tileHalfWidth;\n    }\n\n    /**\n     * Calculates 2D Y position of a tile, given its column and row indices.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param r {number} row index of the tile\n     * @param c {number} column index of the tile\n     * @return {number} 2D Y position of a tile\n     */\n    public getTilePosYFor(r: number, c: number): number {\n        return r * this.tileHalfHeight - c * this.tileHalfHeight;\n    }\n\n    /**\n     * Shows or hides the display object that includes the objects-layer\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param show {boolean} show the object layer, default `false`\n     */\n    public showHideObjectLayer(show: boolean = false): void {\n        this._objContainer.visible = show;\n    }\n    /**\n     * Shows or hides the display object that includes the ground/terrain layer\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param show {boolean} show the ground layer, default `false`\n     */\n    public showHideGroundLayer(show: boolean = false): void {\n        this._groundContainer.visible = show;\n    }\n    /**\n     * Returns the TileView instance that sits in the location given by row and column indices.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param r {number} row index of the tile\n     * @param c {number} column index of the tile\n     * @return {TileView} the tile in the location given\n     */\n    public getTileAtRowAndColumn(r: number, c: number): TileView {\n        return this._tileArray[r][c];\n    }\n    /**\n     * Returns all the ObjectView instances referenced to the given location with the specified row and column indices.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param r {number} the row index of the map location\n     * @param c {number} the column index of the map location\n     * @return {Array(ObjectView)} an array of map-objects referenced to the given location\n     */\n    public getObjectsAtRowAndColumn(r: number, c: number): ObjectView[] {\n        return this._objArray[r][c];\n    }\n    /**\n     * Returns all the ObjectView instances referenced to the given location.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     * @return {Array(ObjectView)} an array of map-objects referenced to the given location\n     */\n    public getObjectsAtLocation(pos: TColumnRowPair): ObjectView[] {\n        return this._objArray[pos.r][pos.c];\n    }\n\n    /**\n     * Creates and adds a predefined (in json file) map-object to the map using the specified object type-id.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param type {number} type-id of the object as defined in the json file\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     * @return {ObjectView} the newly created map-object\n     */\n    public createAndAddObjectToLocation(type: string, pos: TColumnRowPair): ObjectView {\n        return this.addObjectToLocation(new ObjectView(this, type), pos);\n    }\n    /**\n     * Adds an already-created object to the map.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param obj {ObjectView} a map-object to add to the map and the given location\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     * @return {ObjectView} the newly added object\n     */\n    public addObjectToLocation(obj: ObjectView, pos: TColumnRowPair): ObjectView {\n        obj.position.x = this.getTilePosXFor(pos.r, pos.c);\n        obj.position.y = this.getTilePosYFor(pos.r, pos.c) + this.tileHalfHeight;\n        obj.mapPos = { c: pos.c, r: pos.r };\n\n        this._objContainer.addChild(obj);\n\n        this.addObjRefToLocation(obj, obj.mapPos);\n        this.arrangeDepthsFromLocation(obj.isFloorObject ? { c: this._mapSizeC - 1, r: 0 } : obj.mapPos);\n\n        return obj;\n    }\n\n    /**\n     * Enables adding external custom display objects to the specified location.\n     * This method should be used for the objects that are not already defined in json file and don't have a type-id.\n     * The resulting object will be independent of engine mechanics apart from depth controls.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param displayObject {PIXI.DisplayObject} object to be added to location\n     * @param displayObject.isMovableTo {boolean} if the object can be moved onto by other map-objects, default true\n     * @param displayObject.columnSpan {number} number of tiles that map-object covers horizontally on the isometric map\n     * @param displayObject.rowSpan {number} number of tiles that map-object covers vertically on the isometric map\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     * @return {PIXI.DisplayObject} the newly added object\n     */\n    public addCustomObjectToLocation(displayObject: ObjectView, pos: TColumnRowPair): DisplayObject {\n        displayObject.isMovableTo = existy(displayObject.isMovableTo) ? displayObject.isMovableTo : true;\n        displayObject.columnSpan = displayObject.columnSpan || 1;\n        displayObject.rowSpan = displayObject.rowSpan || 1;\n\n        return this.addObjectToLocation(displayObject, pos);\n\n        // this.removeObjRefFromLocation(displayObject, pos);\n    }\n    /**\n     * Removes the object and its references from the map.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param obj {ObjectView} Either an external display object or a map-object (ObjectView)\n     * @param pos {TColumnRowPair} position object including row and column coordinates. If not defined, the engine will use `obj.mapPos` to remove the map-object\n     */\n    public removeObjectFromLocation(obj: ObjectView, pos: TColumnRowPair): void {\n        pos = pos || obj.mapPos;\n        this._objContainer.removeChild(obj);\n        this.removeObjRefFromLocation(obj, pos);\n    }\n    /**\n     * Centralizes and zooms the EngineView instance to the object specified.\n     *\n     * @method focusMapToObject\n     * @param obj {ObjectView} the object that map will be focused with respect to\n     * @param obj.mapPos {Object} the object that holds the location of the map-object on the map\n     * @param obj.mapPos.c {number} the column index of the map location\n     * @param obj.mapPos.r {number} the row index of the map location\n     * @param obj.columnSpan {number} number of tiles that map-object covers horizontally on the isometric map\n     * @param obj.rowSpan {number} number of tiles that map-object covers vertically on the isometric map\n     */\n    public focusMapToObject(obj: ObjectView): void {\n        this.focusMapToLocation(obj.mapPos.c + (obj.columnSpan - 1) / 2, obj.mapPos.r - (obj.rowSpan - 1) / 2, 0);\n    }\n    /**\n     * Centralizes and zooms the EngineView instance to the map location specified by row and column index.\n     *\n     * @method focusMapToLocation\n     * @param c {number} the column index of the map location\n     * @param r {number} the row index of the map location\n     * @param zoomAmount {number} targeted zoom level for focusing\n     */\n    public focusMapToLocation(c: number, r: number, zoomAmount: number): void {\n        // NOTE: using zoomTo instead of setScale causes centralizeToPoint to be called twice (no visual problem)\n        this.zoomTo(zoomAmount, false);\n        this.centralizeToLocation(c, r, this._config.instantCameraRelocation);\n    }\n    /**\n     * Centralizes the EngineView instance to the object specified.\n     *\n     * @method centralizeToObject\n     * @param obj {ObjectView} the object that map will be centralized with respect to\n     * @param obj.mapPos {Object} the object that holds the location of the map-object on the map\n     * @param obj.mapPos.c {number} the column index of the map location\n     * @param obj.mapPos.r {number} the row index of the map location\n     */\n    public centralizeToObject(obj: ObjectView): void {\n        this.centralizeToLocation(obj.mapPos.c, obj.mapPos.r, this._config.instantCameraRelocation);\n    }\n    /**\n     * Centralizes the EngineView instance to the map location specified by row and column index.\n     *\n     * @method centralizeToLocation\n     * @param c {number} the column index of the map location\n     * @param r {number} the row index of the map location\n     * @param [instantRelocate=false] {boolean} specifies if the camera move will be animated or instant\n     */\n    public centralizeToLocation(c: number, r: number, instantRelocate: boolean): void {\n        this._currentFocusLocation = { c: c, r: r };\n        const px =\n            this._externalCenter.x + (this._mapVisualWidthScaled >> 1) - this.getTilePosXFor(r, c) * this._currentScale;\n        const py = this._externalCenter.y - this.getTilePosYFor(r, c) * this._currentScale;\n        this.centralizeToPoint(px, py, instantRelocate);\n    }\n    /**\n     * Centralizes the EngineView instance to the current location of the attention/focus.\n     *\n     * @method centralizeToCurrentFocusLocation\n     * @param [instantRelocate=false] {boolean} specifies if the camera move will be animated or instant\n     */\n    public centralizeToCurrentFocusLocation(instantRelocate: boolean): void {\n        this.centralizeToLocation(this._currentFocusLocation.c, this._currentFocusLocation.r, instantRelocate);\n    }\n    /**\n     * External center is the central point of the frame defined by the user to be used as the visual size of the engine.\n     * This method centralizes the EngineView instance with respect to this external center-point.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param instantRelocate {boolean} specifies if the camera move will be animated or instant\n     */\n    public centralizeToCurrentExternalCenter(instantRelocate: boolean): void {\n        if (this._externalCenter) {\n            this._currentFocusLocation = {\n                c: this._mapSizeC >> 1,\n                r: this._mapSizeR >> 1,\n            };\n            this.centralizeToPoint(this._externalCenter.x, this._externalCenter.y, instantRelocate);\n        }\n    }\n    /**\n     * Centralizes the EngineView instance to the points specified.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param px {number} the x coordinate of the center point with respect to EngineView frame\n     * @param py {number} the y coordinate of the center point with respect to EngineView frame\n     * @param instantRelocate {boolean} specifies if the relocation will be animated or instant\n     */\n    public centralizeToPoint(px: number, py: number, instantRelocate: boolean): void {\n        if (this._tileArray) {\n            px = px - (this._mapVisualWidthScaled >> 1);\n            if (\n                (existy(instantRelocate) && instantRelocate) ||\n                (!existy(instantRelocate) && this._config.instantCameraRelocation)\n            ) {\n                this._mapContainer.position.x = px;\n                this._mapContainer.position.y = py;\n            } else {\n                this.moveEngine.addTween(\n                    this._mapContainer.position as unknown as ITweenTarget,\n                    0.5,\n                    { x: px, y: py },\n                    0,\n                    'easeInOut',\n                    true\n                );\n            }\n        }\n    }\n    /**\n     * Sets all the parameters related to zooming in and out.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param minScale {number} minimum scale that the PIXI.Container for the map can get, default 0.5\n     * @param maxScale {number} maximum scale that the PIXI.Container for the map can get, default 1.5\n     * @param numberOfZoomLevels {number} used to calculate zoom increment, defined by user, default 5\n     * @param initialZoomLevel {number} initial zoom level of the map, default 0\n     * @param instantCameraZoom {boolean} specifies whether to zoom instantly or with a tween animation, default false\n     */\n    public setZoomParameters(\n        minScale: number = 0.5,\n        maxScale: number = 1.5,\n        numberOfZoomLevels: number = 5,\n        initialZoomLevel: number = 0,\n        instantCameraZoom: boolean = false\n    ): void {\n        this._config.minScale = minScale;\n        this._config.maxScale = maxScale;\n        this._config.minZoom = -1;\n        this._config.maxZoom = 1;\n        this._config.zoomIncrement = existy(numberOfZoomLevels)\n            ? numberOfZoomLevels <= 1\n                ? 0\n                : 2 / (numberOfZoomLevels - 1)\n            : 0.5;\n\n        this._config.initialZoomLevel = initialZoomLevel;\n        this._config.instantCameraZoom = instantCameraZoom;\n    }\n    /**\n     * Sets map's scale.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param s {number} Scale amount for both x and y coordinates\n     * @param instantZoom {boolean} Specifies if the scaling will be animated or instant\n     */\n    private setScale(s: number, instantZoom: boolean): void {\n        if (s < this._config.minScale) {\n            s = this._config.minScale;\n        } else if (s > this._config.maxScale) {\n            s = this._config.maxScale;\n        }\n        this._currentScale = s;\n        this._mapVisualWidthScaled = this._mapVisualWidthReal * this._currentScale;\n        // this.mapVisualHeightScaled = this._mapVisualHeightReal * this._currentScale;\n\n        if ((existy(instantZoom) && instantZoom) || (!existy(instantZoom) && this._config.instantCameraZoom)) {\n            this._mapContainer.scale.set(this._currentScale);\n        } else {\n            this.moveEngine.addTween(\n                this._mapContainer.scale as unknown as ITweenTarget,\n                0.5,\n                { x: this._currentScale, y: this._currentScale },\n                0,\n                'easeInOut',\n                true\n            );\n        }\n    }\n    /**\n     * Zooms camera by to the amount given.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param zoomAmount {number} specifies zoom amount (between -1 and 1). Use -1, -0.5, 0, 0,5, 1 for better results.\n     * @param instantZoom {boolean} specifies whether to zoom instantly or with a tween animation\n     */\n    public zoomTo(zoomAmount: number, instantZoom: boolean): void {\n        zoomAmount = zoomAmount || 0;\n        let s = mathMap(\n            zoomAmount,\n            this._config.minZoom,\n            this._config.maxZoom,\n            this._config.minScale,\n            this._config.maxScale,\n            true\n        );\n        s = Math.round(s * 10) / 10;\n\n        this._currentZoom = mathMap(\n            s,\n            this._config.minScale,\n            this._config.maxScale,\n            this._config.minZoom,\n            this._config.maxZoom,\n            true\n        );\n\n        this._externalCenter = this._externalCenter\n            ? this._externalCenter\n            : { x: this._mapVisualWidthScaled >> 1, y: 0 };\n        const diff = {\n            x: this._mapContainer.position.x + (this._mapVisualWidthScaled >> 1) - this._externalCenter.x,\n            y: this._mapContainer.position.y - this._externalCenter.y,\n        };\n        const oldScale = this._currentScale;\n\n        this.setScale(s, instantZoom);\n\n        const ratio = this._currentScale / oldScale;\n        this.centralizeToPoint(\n            this._externalCenter.x + diff.x * ratio,\n            this._externalCenter.y + diff.y * ratio,\n            (existy(instantZoom) && instantZoom) || (!existy(instantZoom) && this._config.instantCameraZoom)\n        );\n\n        // trace(\"scalingTo: \" + this._currentScale);\n        // trace(\"zoomingTo: \" + this._currentZoom);\n    }\n    /**\n     * Zooms the camera one level out.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param instantZoom {boolean} Specifies whether to zoom instantly or with a tween animation\n     */\n    public zoomOut(instantZoom: boolean): void {\n        this.zoomTo(this._currentZoom - this._config.zoomIncrement, instantZoom);\n    }\n    /**\n     * Zooms the camera one level in.\n     *\n     * @method zoomIn\n     * @param [instantZoom=false] {boolean} specifies whether to zoom instantly or with a tween animation\n     */\n    public zoomIn(instantZoom: boolean): void {\n        this.zoomTo(this._currentZoom + this._config.zoomIncrement, instantZoom);\n    }\n    /**\n     * Returns the current controllable map-object.\n     *\n     * @method getCurrentControllable\n     * @return {ObjectView} current controllable map-object\n     */\n    public getCurrentControllable(): ObjectView {\n        return this._currentControllable;\n    }\n    /**\n     * Sets a map-object as the current controllable. This object will be moving in further relevant user interactions.\n     *\n     * @method setCurrentControllable\n     * @param obj {ObjectView} object to be set as current controllable\n     * @param obj.mapPos {Object} object including r and c coordinates\n     * @param obj.mapPos.c {number} the column index of the map location\n     * @param obj.mapPos.r {number} the row index of the map location\n     */\n    public setCurrentControllable(obj: ObjectView): void {\n        this._currentControllable = obj;\n    }\n    /**\n     * Adds a reference of the given map-object to the given location in the object array.\n     * This should be called when an object moved or transferred to the corresponding location.\n     * Uses objects size property to add its reference to all relevant cells.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param obj {ObjectView} object to be bind to location\n     * @param obj.columnSpan {number} number of tiles that map-object covers horizontally on the isometric map\n     * @param obj.rowSpan {number} number of tiles that map-object covers vertically on the isometric map\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     */\n    private addObjRefToLocation(obj: ObjectView, pos: TColumnRowPair): void {\n        let k, m;\n        for (k = pos.c; k < pos.c + obj.columnSpan; k++) {\n            for (m = pos.r; m > pos.r - obj.rowSpan; m--) {\n                this.addObjRefToSingleLocation(obj, { c: k, r: m });\n            }\n        }\n    }\n    /**\n     * Adds a reference of the given map-object to the given location in the object array.\n     * Updates the cell as movable or not according to the object being movable onto or not.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param obj {ObjectView} object to be bind to location\n     * @param obj.isMovableTo {boolean} is the object is movable onto by the other objects or not\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     */\n    private addObjRefToSingleLocation(obj: ObjectView, pos: TColumnRowPair): void {\n        if (!this._objArray[pos.r][pos.c]) {\n            this._objArray[pos.r][pos.c] = [];\n        }\n        const index = this._objArray[pos.r][pos.c].indexOf(obj);\n        if (index < 0) {\n            this._objArray[pos.r][pos.c].push(obj);\n        }\n\n        if (!obj.isMovableTo) {\n            this._pathFinding.setDynamicCell(pos.c, pos.r, 0);\n        }\n    }\n    /**\n     * Removes references of the given map-object from the given location in the object array.\n     * This should be called when an object moved or transferred from the corresponding location.\n     * Uses objects size property to remove its references from all relevant cells.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param obj {ObjectView} object to be bind to location\n     * @param obj.columnSpan {number} number of tiles that map-object covers horizontally on the isometric map\n     * @param obj.rowSpan {number} number of tiles that map-object covers vertically on the isometric map\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     */\n    private removeObjRefFromLocation(obj: ObjectView, pos: TColumnRowPair): void {\n        let k, m;\n        for (k = pos.c; k < pos.c + obj.columnSpan; k++) {\n            for (m = pos.r; m > pos.r - obj.rowSpan; m--) {\n                this.removeObjRefFromSingleLocation(obj, { c: k, r: m });\n            }\n        }\n    }\n    /**\n     * Removes a reference of the given map-object from the given location in the object array.\n     * Updates the cell as movable or not according to the other object references in the same cell.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param obj {ObjectView} object to be bind to location\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     */\n    private removeObjRefFromSingleLocation(obj: ObjectView, pos: TColumnRowPair): void {\n        if (this._objArray[pos.r][pos.c]) {\n            const index = this._objArray[pos.r][pos.c].indexOf(obj);\n            if (index > -1) {\n                this._objArray[pos.r][pos.c].splice(index, 1);\n            }\n            if (this._objArray[pos.r][pos.c].length === 0) {\n                this._pathFinding.setDynamicCell(pos.c, pos.r, 1);\n                this._objArray[pos.r][pos.c] = null;\n            } else {\n                const a = this._objArray[pos.r][pos.c];\n                const l = a.length;\n                for (let i = 0; i < l; i++) {\n                    if (!a[i].isMovableTo) {\n                        this._pathFinding.setDynamicCell(pos.c, pos.r, 0);\n                        break;\n                    } else if (i === l - 1) {\n                        this._pathFinding.setDynamicCell(pos.c, pos.r, 1);\n                    }\n                }\n            }\n        }\n    }\n    // /**\n    //  * Removes all map-object references from the given location in the object array.\n    //  *\n    //  * @private\n    //  * @method removeAllObjectRefsFromLocation\n    //  * @param {TColumnRowPair} pos object including r and c coordinates\n    //  */\n    // private removeAllObjectRefsFromLocation(pos: TColumnRowPair): void {\n    //     if (this._objArray[pos.r][pos.c]) {\n    //         this._pathFinding.setDynamicCell(pos.c, pos.r, 1);\n    //         this._objArray[pos.r][pos.c] = null;\n    //     }\n    // }\n    /**\n     * Sets alphas of the map-objects referenced to the given location.\n     *\n     * @method changeObjAlphasInLocation\n     * @param value {number} alpha value, should be between 0 and 1\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     */\n    public changeObjAlphasInLocation(value: number, pos: TColumnRowPair): void {\n        const a = this._objArray[pos.r][pos.c];\n        if (a) {\n            const l = a.length;\n            for (let i = 0; i < l; i++) {\n                if (!a[i].isFloorObject && !a[i].noTransparency) {\n                    a[i].alpha = value;\n                }\n            }\n        }\n    }\n    /**\n     * Sets a map-object's location and logically moves it to the new location.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param obj {ObjectView} map-object to be moved\n     * @param obj.mapPos {Object} object including r and c coordinates\n     * @param obj.mapPos.c {number} the column index of the map location\n     * @param obj.mapPos.r {number} the row index of the map location\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     */\n    private arrangeObjLocation(obj: ObjectView, pos: TColumnRowPair): void {\n        this.removeObjRefFromLocation(obj, obj.mapPos);\n        this.addObjRefToLocation(obj, pos);\n\n        obj.mapPos = { c: pos.c, r: pos.r };\n    }\n    /**\n     * Sets occlusion transparencies according to given map-object's location.\n     * This method only works for user-controllable object.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param obj {ObjectView} current controllable map-object\n     * @param prevPos {TColumnRowPair} previous location of the map-object in terms of row and column coordinates\n     * @param pos {TColumnRowPair} new location of the map-object in terms of row and column coordinates\n     */\n    private arrangeObjTransparencies(obj: ObjectView, prevPos: TColumnRowPair, pos: TColumnRowPair): void {\n        if (this._config.changeTransparencies) {\n            if (this._currentControllable === obj) {\n                if (prevPos.c > 0) {\n                    this.changeObjAlphasInLocation(1, {\n                        c: prevPos.c - 1,\n                        r: prevPos.r,\n                    });\n                }\n                if (prevPos.c > 0 && prevPos.r < this._mapSizeR - 1) {\n                    this.changeObjAlphasInLocation(1, {\n                        c: prevPos.c - 1,\n                        r: prevPos.r + 1,\n                    });\n                }\n                if (prevPos.r < this._mapSizeR - 1) {\n                    this.changeObjAlphasInLocation(1, {\n                        c: prevPos.c,\n                        r: prevPos.r + 1,\n                    });\n                }\n\n                if (pos.c > 0) {\n                    this.changeObjAlphasInLocation(0.7, {\n                        c: pos.c - 1,\n                        r: pos.r,\n                    });\n                }\n                if (pos.c > 0 && pos.r < this._mapSizeR - 1) {\n                    this.changeObjAlphasInLocation(0.7, {\n                        c: pos.c - 1,\n                        r: pos.r + 1,\n                    });\n                }\n                if (pos.r < this._mapSizeR - 1) {\n                    this.changeObjAlphasInLocation(0.7, {\n                        c: pos.c,\n                        r: pos.r + 1,\n                    });\n                }\n            }\n\n            // TODO: check if there is a way not to update main character alpha each time\n            obj.alpha = 1;\n        }\n    }\n    /**\n     * Arranges depths (z-index) of the map-objects starting from the given location.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     */\n    private arrangeDepthsFromLocation(pos: TColumnRowPair): void {\n        let a, i, j, k;\n        for (i = pos.r; i < this._mapSizeR; i++) {\n            for (j = pos.c; j >= 0; j--) {\n                a = this._objArray[i][j];\n                if (a) {\n                    for (k = 0; k < a.length; k++) {\n                        if (!a[k].isFloorObject) {\n                            this._objContainer.addChild(a[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Clears the highlight for the old path and highlights the new path on map.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param currentPath {Array(GridNode)} the old path to clear the highlight from\n     * @param newPath {Array(GridNode)} the new path to highlight\n     */\n    private arrangePathHighlight(currentPath: GridNode[], newPath: GridNode[]): void {\n        let i: number, tile: TileView, pathItem: GridNode;\n        if (currentPath) {\n            for (i = 0; i < currentPath.length; i++) {\n                pathItem = currentPath[i];\n                if (!newPath || newPath.indexOf(pathItem) === -1) {\n                    tile = this._tileArray[pathItem.mapPos.r][pathItem.mapPos.c];\n                    tile.setHighlighted(false, !this._config.tileHighlightAnimated);\n                }\n            }\n        }\n        if (newPath) {\n            for (i = 0; i < newPath.length; i++) {\n                pathItem = newPath[i];\n                if (!currentPath || currentPath.indexOf(pathItem) === -1) {\n                    tile = this._tileArray[pathItem.mapPos.r][pathItem.mapPos.c];\n                    tile.setHighlighted(true, !this._config.tileHighlightAnimated);\n                }\n            }\n        }\n    }\n    /**\n     * Stops a moving object.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param obj {IMovable} map-object to be moved on path\n     */\n    private stopObject(obj: IMovable): void {\n        obj.currentPath = null;\n        obj.currentTarget = null;\n        obj.currentTargetTile = null;\n        this.moveEngine.removeMovable(obj);\n    }\n    /**\n     * Moves the specified map-object through a path.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param obj {IMovable} map-object to be moved on path\n     * @param path {Array(GridNode)} path to move object on\n     * @param speed {number} speed of the map-object to be used during movement, if not defined it uses previous speed or the MoveEngine's default speed, default null\n     */\n    private moveObjThrough(obj: IMovable, path: GridNode[], speed: number = null): void {\n        if (this._config.instantObjectRelocation) {\n            const tile = this._tileArray[path[0].mapPos.r][path[0].mapPos.c];\n            obj.position.x = tile.position.x;\n            obj.position.y = tile.position.y + this.tileHalfHeight;\n            this.arrangeObjTransparencies(obj, obj.mapPos, tile.mapPos);\n            this.arrangeObjLocation(obj, tile.mapPos);\n            this.arrangeDepthsFromLocation(tile.mapPos);\n        } else {\n            if (this._config.highlightPath && this._currentControllable === obj) {\n                this.arrangePathHighlight(obj.currentPath, path);\n            }\n\n            if (obj.currentTarget) {\n                // trace(\"Object has a target, update the path with the new one\");\n                // this.moveEngine.addNewPathToObject(obj, path, speed);\n                this.stopObject(obj);\n            }\n\n            this.moveEngine.prepareForMove(obj, path, speed);\n\n            obj.currentTargetTile = obj.currentPath[obj.currentPathStep];\n\n            this.onObjMoveStepBegin(obj, obj.currentPath[obj.currentPathStep].mapPos);\n        }\n    }\n    /**\n     * Sets up the engine at the beginning of each tile change move for the specified object\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param obj {IMovable} map-object that is being moved\n     * @param pos {TColumnRowPair} position object including row and column coordinates\n     * @return {boolean} if the target tile was available and map-object has moved\n     */\n    private onObjMoveStepBegin(obj: IMovable, pos: TColumnRowPair): boolean {\n        // trace(\"onObjMoveStepBegin\");\n        // Note that mapPos is being updated prior to movement\n\n        obj.currentDirection = getDirBetween(obj.mapPos.r, obj.mapPos.c, pos.r, pos.c);\n\n        obj.changeVisualToDirection(obj.currentDirection, true);\n\n        // check if the next target pos is still empty\n        if (!this._pathFinding.isCellFilled(pos.c, pos.r)) {\n            // pos is movable\n            // this.arrangeObjTransparencies(obj, obj.mapPos, pos);\n            // this.arrangeObjLocation(obj, pos);\n            // this.arrangeDepthsFromLocation(obj.mapPos);\n\n            // if there is other object(s) on the target tile, notify the game\n            // const objects = this.getObjectsAtLocation(pos);\n            // if (objects && objects.length > 1)\n            // {\n            // if (this._config.otherObjectsOnTheNextTileCallback) { this._config.otherObjectsOnTheNextTileCallback( obj, objects ); }\n            // }\n\n            this.moveEngine.setMoveParameters(obj, pos);\n\n            this.moveEngine.addMovable(obj);\n\n            return true;\n        } else {\n            // pos is NOT movable\n            this.moveEngine.removeMovable(obj);\n            this.checkAndMoveObjectToLocation(obj, obj.currentPath[0].mapPos);\n\n            return false;\n        }\n    }\n    /**\n     * Sets up the engine at the end of each tile change move for the specified object\n     *\n     * @method\n     * @function\n     * @public\n     * @internal\n     *\n     * @param obj {IMovable} map-object that is being moved\n     */\n    public onObjMoveStepEnd(obj: IMovable): void {\n        //trace(\"onObjMoveStepEnd\");\n\n        obj.currentPathStep--;\n        obj.currentTarget = null;\n        obj.currentTargetTile = null;\n        const pathEnded = 0 > obj.currentPathStep;\n        this.moveEngine.removeMovable(obj);\n\n        if (!pathEnded) {\n            if (this._config.checkPathOnEachTile) {\n                this.checkAndMoveObjectToLocation(obj, obj.currentPath[0].mapPos);\n            } else {\n                obj.currentPath.splice(obj.currentPath.length - 1, 1);\n                this.moveObjThrough(obj, obj.currentPath);\n            }\n        } else {\n            // reached to the end of the path\n            obj.changeVisualToDirection(obj.currentDirection, false);\n        }\n\n        if (this._currentControllable === obj) {\n            const tile = this._tileArray[obj.mapPos.r][obj.mapPos.c];\n            tile.setHighlighted(false, !this._config.tileHighlightAnimated);\n\n            // if (this._config.followCharacter) { this.centralizeToLocation(obj.mapPos.c, obj.mapPos.r); }\n        }\n\n        if (pathEnded && this._config.objectReachedDestinationCallback) {\n            this._config.objectReachedDestinationCallback(obj);\n        }\n    }\n\n    /**\n     * Checks and follows a character\n     *\n     * @method\n     * @function\n     * @public\n     * @internal\n     *\n     * @param obj {IMovable} map-object to check if it is being followed\n     */\n    public checkForFollowCharacter(obj: IMovable): void {\n        if (this._config.followCharacter && this._currentControllable === obj) {\n            this._currentFocusLocation = { c: obj.mapPos.c, r: obj.mapPos.r };\n            const px = this._externalCenter.x - obj.position.x * this._currentScale;\n            const py = this._externalCenter.y - obj.position.y * this._currentScale;\n            // this.centralizeToPoint(px, py, true);\n            this.moveEngine.addTween(\n                this._mapContainer.position as unknown as ITweenTarget,\n                0.1,\n                { x: px, y: py },\n                0,\n                'easeOut',\n                true\n            );\n        }\n    }\n\n    /**\n     * Checks if a map-object changes the tile it is on.\n     *\n     * @method\n     * @function\n     * @public\n     * @internal\n     *\n     * @param obj {IMovable} map-object to be checked\n     */\n    public checkForTileChange(obj: IMovable): void {\n        if (this._config.objectUpdateCallback) {\n            this._config.objectUpdateCallback(obj);\n        }\n\n        const pos = { x: obj.position.x, y: obj.position.y - this.tileHalfHeight };\n        // const tile = this._tileArray[obj.mapPos.r][obj.mapPos.c];\n        const tile = this._tileArray[obj.currentTargetTile.mapPos.r][obj.currentTargetTile.mapPos.c];\n        // move positions to parent scale\n        const vertices = [];\n        for (let i = 0; i < tile.vertices.length; i++) {\n            vertices[i] = [tile.vertices[i][0] + tile.position.x, tile.vertices[i][1] + tile.position.y];\n        }\n\n        if (obj.currentTargetTile.mapPos.r !== obj.mapPos.r || obj.currentTargetTile.mapPos.c !== obj.mapPos.c) {\n            if (isInPolygon(pos, vertices)) {\n                this.arrangeObjTransparencies(obj, obj.mapPos, obj.currentTargetTile.mapPos);\n                this.arrangeObjLocation(obj, obj.currentTargetTile.mapPos);\n                this.arrangeDepthsFromLocation(obj.mapPos);\n\n                // if there is other object(s) on the target tile, notify the game\n                const objects = this.getObjectsAtLocation(obj.currentTargetTile.mapPos);\n                if (objects && objects.length > 1) {\n                    if (this._config.otherObjectsOnTheNextTileCallback) {\n                        this._config.otherObjectsOnTheNextTileCallback(obj, objects);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Searches and returns a path between two locations if there is one.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param from {TColumnRowPair} object including row and column coordinates of the source location\n     * @param to {TColumnRowPair} object including row and column coordinates of the target location\n     *\n     * @return {Array(Object)} an array of path items defining the path\n     */\n    public getPath(from: TColumnRowPair, to: TColumnRowPair): GridNode[] {\n        if (this._pathFinding) {\n            return this._pathFinding.solve(from.c, from.r, to.c, to.r);\n        } else {\n            throw new Error(\"Path finding hasn't been initialized yet!\");\n        }\n    }\n    /**\n     * Checks for a path and moves the map-object on map if there is an available path\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param obj {ObjectView} map-object that is being moved\n     * @param tile {TileView} target map-tile or any custom object that has 'mapPos' and 'isMovableTo' defined\n     * @param speed {number} speed of the map-object to be used during movement, if not defined it uses previous speed or the MoveEngine's default speed, default null\n     * @return {boolean} if there is an available path to move to the target tile\n     */\n    public checkAndMoveObjectToTile(obj: ObjectView, tile: TileView, speed: number = null): boolean {\n        if (tile.isMovableTo) {\n            return this.checkAndMoveObjectToLocation(obj, tile.mapPos, speed);\n        }\n        return false;\n    }\n    /**\n     * Checks for a path and moves the map-object on map if there is an available path\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param obj {ObjectView} map-object that is being moved\n     * @param pos {TColumnRowPair} object including row and column coordinates for the target location\n     * @param speed {number} speed of the map-object to be used during movement, if not defined it uses previous speed or the MoveEngine's default speed, default null\n     * @return {boolean} if there is an available path to move to the target tile\n     */\n    public checkAndMoveObjectToLocation(obj: ObjectView, pos: TColumnRowPair, speed: number = null): boolean {\n        const path = this.getPath(obj.mapPos, pos);\n        if (path) {\n            // begin moving process\n            this.moveObjThrough(obj as IMovable, path, speed);\n\n            return path.length > 0;\n        }\n        return false;\n    }\n    /**\n     * Moves the current controllable map-object to a location if available.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param pos {TColumnRowPair} object including row and column coordinates for the target location\n     * @param speed {number} speed of the map-object to be used during movement, if not defined it uses previous speed or the MoveEngine's default speed, default null\n     * @return {boolean} if there is an available path to move to the target tile\n     */\n    public moveCurrentControllableToLocation(pos: TColumnRowPair, speed: number = null): boolean {\n        if (!this._currentControllable) {\n            throw new Error('TRAVISO: _currentControllable is not defined!');\n        }\n        return this.checkAndMoveObjectToLocation(this._currentControllable, pos, speed);\n    }\n    /**\n     * Moves the current controllable map-object to one of the adjacent available tiles of the map-object specified.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param obj {ObjectView} target map-object\n     * @param speed {number} speed of the map-object to be used during movement, if not defined it uses previous speed or the MoveEngine's default speed, default null\n     * @return {boolean} if there is an available path to move to the target map-object\n     */\n    public moveCurrentControllableToObj(obj: ObjectView, speed: number = null): boolean {\n        if (!this._currentControllable) {\n            throw new Error('TRAVISO: _currentControllable is not defined!');\n        }\n        // check if there is a preferred interaction point\n        if (obj.currentInteractionOffset) {\n            const targetPos = {\n                c: obj.mapPos.c + obj.currentInteractionOffset.c,\n                r: obj.mapPos.r + obj.currentInteractionOffset.r,\n            };\n            if (this.checkAndMoveObjectToLocation(this._currentControllable, targetPos, speed)) {\n                return true;\n            }\n        }\n        const cellArray = this._pathFinding.getAdjacentOpenCells(\n            obj.mapPos.c,\n            obj.mapPos.r,\n            obj.columnSpan,\n            obj.rowSpan\n        );\n        let tile: TileView;\n        let minLength = 3000;\n        let path, minPath, tempFlagHolder;\n        for (let i = 0; i < cellArray.length; i++) {\n            tile = this._tileArray[cellArray[i].mapPos.r][cellArray[i].mapPos.c];\n            if (tile) {\n                if (\n                    tile.mapPos.c === this._currentControllable.mapPos.c &&\n                    tile.mapPos.r === this._currentControllable.mapPos.r\n                ) {\n                    // already next to the object, do nothing\n                    this.arrangePathHighlight((this._currentControllable as IMovable).currentPath, null);\n                    this.stopObject(this._currentControllable as IMovable);\n                    tempFlagHolder = this._config.instantObjectRelocation;\n                    this._config.instantObjectRelocation = true;\n                    this.moveObjThrough(this._currentControllable as IMovable, [\n                        new GridNode(tile.mapPos.c, tile.mapPos.r, 1),\n                    ]);\n                    this._config.instantObjectRelocation = tempFlagHolder;\n                    this._currentControllable.changeVisualToDirection(\n                        this._currentControllable.currentDirection,\n                        false\n                    );\n                    if (this._config.objectReachedDestinationCallback) {\n                        this._config.objectReachedDestinationCallback(this._currentControllable);\n                    }\n                    return true;\n                }\n                path = this.getPath(this._currentControllable.mapPos, tile.mapPos);\n                if (path && path.length < minLength) {\n                    minLength = path.length;\n                    minPath = path;\n                }\n            }\n        }\n\n        if (minPath) {\n            this.moveObjThrough(this._currentControllable as IMovable, minPath, speed);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Finds the nearest tile to the point given in the map's local scope.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param lp {TPositionPair} Point to check\n     * @return {TileView} The nearest map-tile if there is one. Otherwise `null`\n     */\n    public getTileFromLocalPos(lp: TPositionPair): TileView {\n        let closestTile: TileView = null;\n        if (isInPolygon(lp, this._mapVertices)) {\n            // Using nearest point instead of checking polygon vertices for each tile. Should be faster...\n            // NOTE: there is an ignored bug (for better performance) that tile is not selected when u click on the far corner\n            const thresh = this.tileHalfWidth / 2;\n            let tile, i, j, dist;\n            let closestDist = 3000;\n            for (i = 0; i < this._mapSizeR; i++) {\n                for (j = 0; j < this._mapSizeC; j++) {\n                    tile = this._tileArray[i][j];\n                    if (tile) {\n                        dist = getDist(lp, tile.position);\n                        if (dist < closestDist) {\n                            closestDist = dist;\n                            closestTile = tile;\n                            if (dist < thresh) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return closestTile;\n    }\n    /**\n     * Checks if an interaction occurs using the interaction data coming from PIXI.\n     * If there is any interaction starts necessary movements or performs necessary callbacks.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param interactionData {PIXI.InteractionData} interaction data coming from PIXI\n     */\n    private checkForTileClick(interactionData: InteractionData): void {\n        const lp = this._mapContainer.toLocal(interactionData.global);\n        const closestTile = this.getTileFromLocalPos(lp);\n        if (closestTile) {\n            const a = this._objArray[closestTile.mapPos.r][closestTile.mapPos.c];\n            if (a) {\n                for (let k = 0; k < a.length; k++) {\n                    if (a[k].isInteractive) {\n                        if (this._config.objectSelectCallback) {\n                            this._config.objectSelectCallback(a[k]);\n                        }\n                        break;\n                    }\n                    // TODO CHECK: this might cause issues when there is one movable and one not movable object on the same tile\n                    else if (a[k].isMovableTo) {\n                        if (\n                            this._config.dontAutoMoveToTile ||\n                            !this._currentControllable ||\n                            this.checkAndMoveObjectToTile(this._currentControllable, closestTile)\n                        ) {\n                            if (this._config.highlightTargetTile) {\n                                closestTile.setHighlighted(true, !this._config.tileHighlightAnimated);\n                            }\n                            if (this._config.tileSelectCallback) {\n                                this._config.tileSelectCallback(closestTile.mapPos.r, closestTile.mapPos.c);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } else if (\n                this._config.dontAutoMoveToTile ||\n                !this._currentControllable ||\n                this.checkAndMoveObjectToTile(this._currentControllable, closestTile)\n            ) {\n                if (this._config.highlightTargetTile) {\n                    closestTile.setHighlighted(true, !this._config.tileHighlightAnimated);\n                }\n                if (this._config.tileSelectCallback) {\n                    this._config.tileSelectCallback(closestTile.mapPos.r, closestTile.mapPos.c);\n                }\n            }\n        }\n    }\n    /**\n     * Enables mouse/touch interactions.\n     *\n     * @method\n     * @function\n     * @public\n     */\n    public enableInteraction(): void {\n        // this.mousedown = this.touchstart = this.onMouseDown.bind(this);\n        // this.mousemove = this.touchmove = this.onMouseMove.bind(this);\n        // this.mouseup = this.mouseupout = this.touchend = this.onMouseUp.bind(this);\n        this.on('pointerdown', this.onMouseDown_binded)\n            .on('pointerup', this.onMouseUp_binded)\n            // .on('pointerout', this.onMouseUp_binded)\n            .on('pointerupoutside', this.onMouseUp_binded)\n            .on('pointermove', this.onMouseMove_binded);\n        this.interactive = true;\n    }\n    /**\n     * Disables mouse/touch interactions.\n     *\n     * @method\n     * @function\n     * @public\n     */\n    public disableInteraction(): void {\n        // this.mousedown = this.touchstart = null;\n        // this.mousemove = this.touchmove = null;\n        // this.mouseup = this.mouseupout = this.touchend = null;\n        this.off('pointerdown', this.onMouseDown_binded)\n            .off('pointerup', this.onMouseUp_binded)\n            // .off('pointerout', this.onMouseUp_binded)\n            .off('pointerupoutside', this.onMouseUp_binded)\n            .off('pointermove', this.onMouseMove_binded);\n        this.interactive = true;\n        this._dragging = false;\n    }\n    /**\n     * Checks if the given point is inside the masked area if there is a mask defined.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param p {TPositionPair} point to check\n     * @return {boolean} if the point is inside the masked area\n     */\n    private isInteractionInMask(p: TPositionPair): boolean {\n        if (this._config.useMask) {\n            if (\n                p.x < this._posFrame.x ||\n                p.y < this._posFrame.y ||\n                p.x > this._posFrame.x + this._posFrame.w ||\n                p.y > this._posFrame.y + this._posFrame.h\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // ******************** START: MOUSE INTERACTIONS **************************** //\n    /**\n     * Handler function for mouse-down event.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param event {InteractionEvent} interaction event object\n     */\n    private onMouseDown(event: InteractionEvent): void {\n        const globalPos = event.data.global;\n        if (!this._dragging && this.isInteractionInMask(globalPos)) {\n            this._dragging = true;\n            //this.mouseDownTime = new Date();\n            this._dragInitStartingX = this._dragPrevStartingX = globalPos.x;\n            this._dragInitStartingY = this._dragPrevStartingY = globalPos.y;\n        }\n    }\n    /**\n     * Handler function for mouse-move event.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param event {InteractionEvent} interaction event object\n     */\n    private onMouseMove(event: InteractionEvent): void {\n        if (this._dragging && this._config.mapDraggable) {\n            const globalPos = event.data.global;\n            this._mapContainer.position.x += globalPos.x - this._dragPrevStartingX;\n            this._mapContainer.position.y += globalPos.y - this._dragPrevStartingY;\n            this._dragPrevStartingX = globalPos.x;\n            this._dragPrevStartingY = globalPos.y;\n        }\n    }\n    /**\n     * Handler function for mouse-up event.\n     *\n     * @method\n     * @function\n     * @private\n     * @internal\n     *\n     * @param event {InteractionEvent} interaction event object\n     */\n    private onMouseUp(event: InteractionEvent): void {\n        if (this._dragging) {\n            this._dragging = false;\n            //const passedTime = (new Date()) - this.mouseDownTime;\n            const distX = event.data.global.x - this._dragInitStartingX;\n            const distY = event.data.global.y - this._dragInitStartingY;\n\n            if (Math.abs(distX) < 5 && Math.abs(distY) < 5) {\n                // NOT DRAGGING IT IS A CLICK\n                this.checkForTileClick(event.data);\n            }\n        }\n    }\n    // ********************* END: MOUSE INTERACTIONS **************************** //\n    /**\n     * Repositions the content according to user settings. Call this method\n     * whenever you want to change the size or position of the engine.\n     *\n     * @method\n     * @function\n     * @public\n     *\n     * @param posFrame {TPositionFrame} frame to position the engine, default is the previously set posFrame and if not set, it is `{ x : 0, y : 0, w : 800, h : 600 }`\n     */\n    public repositionContent(posFrame: TPositionFrame = null): void {\n        trace('EngineView repositionContent');\n\n        posFrame = posFrame || this._posFrame || { x: 0, y: 0, w: 800, h: 600 };\n\n        this.position.x = posFrame.x;\n        this.position.y = posFrame.y;\n\n        this._externalCenter = {\n            x: posFrame.w >> 1,\n            y: posFrame.h >> 1,\n        };\n        this.centralizeToCurrentFocusLocation(true);\n\n        if (this._bg) {\n            this._bg.clear();\n            // this._bg.lineStyle(2, 0x000000, 1);\n            this._bg.beginFill(this._config.backgroundColor, 1.0);\n            this._bg.drawRect(0, 0, posFrame.w, posFrame.h);\n            this._bg.endFill();\n        }\n\n        if (this._mapMask && this._mapContainer) {\n            this._mapMask.clear();\n            this._mapMask.beginFill(0x000000);\n            this._mapMask.drawRect(0, 0, posFrame.w, posFrame.h);\n            this._mapMask.endFill();\n\n            this._mapContainer.mask = this._mapMask;\n        }\n\n        this._posFrame = posFrame;\n    }\n    /**\n     * Clears all references and stops all animations inside the engine.\n     * Call this method when you want to get rid of an engine instance.\n     *\n     * @method\n     * @function\n     * @public\n     */\n    public destroy(): void {\n        trace('EngineView destroy');\n\n        this.disableInteraction();\n\n        this.moveEngine.destroy();\n        this.moveEngine = null;\n\n        let item, i, j, k;\n        for (i = 0; i < this._mapSizeR; i++) {\n            for (j = this._mapSizeC - 1; j >= 0; j--) {\n                item = this._tileArray[i][j];\n                if (item) {\n                    item.destroy();\n                    // this._groundContainer.removeChild(item);\n                }\n                this._tileArray[i][j] = null;\n\n                item = this._objArray[i][j];\n                if (item) {\n                    for (k = 0; k < item.length; k++) {\n                        if (item[k]) {\n                            item[k].destroy();\n                            // this._objContainer.removeChild(item[k]);\n                        }\n                        item[k] = null;\n                    }\n                }\n                this._objArray[i][j] = null;\n            }\n        }\n        item = null;\n\n        this._pathFinding.destroy();\n        this._pathFinding = null;\n\n        this._currentControllable = null;\n        this._tileArray = null;\n        this._objArray = null;\n        this._bg = null;\n        this._groundContainer = null;\n        this._objContainer = null;\n\n        if (this._mapContainer) {\n            this._mapContainer.mask = null;\n            this.removeChild(this._mapContainer);\n            this._mapContainer = null;\n        }\n        if (this._mapMask) {\n            this.removeChild(this._mapMask);\n            this._mapMask = null;\n        }\n\n        this._config = null;\n        this.mapData.groundMapData = null;\n        this.mapData.objectsMapData = null;\n        this.mapData.objects = null;\n        this.mapData.tiles = null;\n        this.mapData = null;\n    }\n\n    // Externally modifiable properties for EngineView\n    /**\n     * specifies whether to zoom instantly or with a tween animation\n     * @property\n     * @default false\n     */\n    public get instantCameraZoom(): boolean {\n        return this._config.instantCameraZoom;\n    }\n    public set instantCameraZoom(value: boolean) {\n        this._config.instantCameraZoom = value;\n    }\n    /**\n     * defines if the camera will follow the current controllable or not\n     * @property\n     * @default true\n     */\n    public get followCharacter(): boolean {\n        return this._config.followCharacter;\n    }\n    public set followCharacter(value: boolean) {\n        this._config.followCharacter = value;\n    }\n    /**\n     * specifies whether the camera moves instantly or with a tween animation to the target location\n     * @property\n     * @default false\n     */\n    public get instantCameraRelocation(): boolean {\n        return this._config.instantCameraRelocation;\n    }\n    public set instantCameraRelocation(value: boolean) {\n        this._config.instantCameraRelocation = value;\n    }\n    /**\n     * specifies whether the map-objects will be moved to target location instantly or with an animation\n     * @property\n     * @default false\n     */\n    public get instantObjectRelocation(): boolean {\n        return this._config.instantObjectRelocation;\n    }\n    public set instantObjectRelocation(value: boolean) {\n        this._config.instantObjectRelocation = value;\n    }\n    /**\n     * make objects transparent when the controllable is behind them\n     * @property\n     * @default true\n     */\n    public get changeTransparencies(): boolean {\n        return this._config.changeTransparencies;\n    }\n    public set changeTransparencies(value: boolean) {\n        this._config.changeTransparencies = value;\n    }\n    /**\n     * highlight the path when the current controllable moves on the map\n     * @property\n     * @default true\n     */\n    public get highlightPath(): boolean {\n        return this._config.highlightPath;\n    }\n    public set highlightPath(value: boolean) {\n        this._config.highlightPath = value;\n    }\n    /**\n     * Highlight the target tile when the current controllable moves on the map\n     * @property\n     * @default true\n     */\n    public get highlightTargetTile(): boolean {\n        return this._config.highlightTargetTile;\n    }\n    public set highlightTargetTile(value: boolean) {\n        this._config.highlightTargetTile = value;\n    }\n    /**\n     * animate the tile highlights\n     * @property\n     * @default true\n     */\n    public get tileHighlightAnimated(): boolean {\n        return this._config.tileHighlightAnimated;\n    }\n    public set tileHighlightAnimated(value: boolean) {\n        this._config.tileHighlightAnimated = value;\n    }\n    /**\n     * When a tile selected don't move the controllable immediately but still call 'tileSelectCallback'\n     * @property\n     * @default false\n     */\n    public get dontAutoMoveToTile(): boolean {\n        return this._config.dontAutoMoveToTile;\n    }\n    public set dontAutoMoveToTile(value: boolean) {\n        this._config.dontAutoMoveToTile = value;\n    }\n    /**\n     * Engine looks for a path every time an object moves to a new tile on the path\n     * (set to false if you don't have moving objects other then your controllable on your map)\n     * @property\n     * @default true\n     */\n    public get checkPathOnEachTile(): boolean {\n        return this._config.checkPathOnEachTile;\n    }\n    public set checkPathOnEachTile(value: boolean) {\n        this._config.checkPathOnEachTile = value;\n    }\n    /**\n     * enable dragging the map with touch-and-touchmove or mousedown-and-mousemove on the map\n     * @property\n     * @default true\n     */\n    public get mapDraggable(): boolean {\n        return this._config.mapDraggable;\n    }\n    public set mapDraggable(value: boolean) {\n        this._config.mapDraggable = value;\n    }\n    /**\n     * callback function that will be called once everything is loaded and engine instance is ready\n     * @property\n     * @default null\n     */\n    public get engineInstanceReadyCallback(): (engineInstance: EngineView) => unknown {\n        return this._config.engineInstanceReadyCallback;\n    }\n    public set engineInstanceReadyCallback(value: (engineInstance: EngineView) => unknown) {\n        this._config.engineInstanceReadyCallback = value;\n    }\n    /**\n     * callback function that will be called when a tile is selected. Params will be the row and column indexes of the tile selected.\n     * @property\n     * @default null\n     */\n    public get tileSelectCallback(): (r: number, c: number) => unknown {\n        return this._config.tileSelectCallback;\n    }\n    public set tileSelectCallback(value: (r: number, c: number) => unknown) {\n        this._config.tileSelectCallback = value;\n    }\n    /**\n     * callback function that will be called when a tile with an interactive map-object on it is selected. Call param will be the object selected.\n     * @property\n     * @default null\n     */\n    public get objectSelectCallback(): (objectView: ObjectView) => unknown {\n        return this._config.objectSelectCallback;\n    }\n    public set objectSelectCallback(value: (objectView: ObjectView) => unknown) {\n        this._config.objectSelectCallback = value;\n    }\n    /**\n     * callback function that will be called when any moving object reaches its destination. Call param will be the moving object itself.\n     * @property\n     * @default null\n     */\n    public get objectReachedDestinationCallback(): (objectView: ObjectView) => unknown {\n        return this._config.objectReachedDestinationCallback;\n    }\n    public set objectReachedDestinationCallback(value: (objectView: ObjectView) => unknown) {\n        this._config.objectReachedDestinationCallback = value;\n    }\n    /**\n     * callback function that will be called when any moving object is in move and there are other objects on the next tile. Call params will be the moving object and an array of objects on the next tile.\n     * @property\n     * @default null\n     */\n    public get otherObjectsOnTheNextTileCallback(): (\n        objectView: ObjectView,\n        otherObjectViews: ObjectView[]\n    ) => unknown {\n        return this._config.otherObjectsOnTheNextTileCallback;\n    }\n    public set otherObjectsOnTheNextTileCallback(\n        value: (objectView: ObjectView, otherObjectViews: ObjectView[]) => unknown\n    ) {\n        this._config.otherObjectsOnTheNextTileCallback = value;\n    }\n    /**\n     * callback function that will be called every time an objects direction or position changed\n     * @property\n     * @default null\n     */\n    public get objectUpdateCallback(): (objectView: ObjectView) => unknown {\n        return this._config.objectUpdateCallback;\n    }\n    public set objectUpdateCallback(value: (objectView: ObjectView) => unknown) {\n        this._config.objectUpdateCallback = value;\n    }\n    /**\n     * alpha value for the tile highlight stroke (this will be overridden if a highlight-image is defined)\n     * @property\n     * @default 1.0\n     */\n    public get tileHighlightStrokeAlpha(): number {\n        return this._config.tileHighlightStrokeAlpha;\n    }\n    public set tileHighlightStrokeAlpha(value: number) {\n        this._config.tileHighlightStrokeAlpha = value;\n    }\n    /**\n     * color code for the tile highlight stroke (this will be overridden if a highlight-image is defined)\n     * @property\n     * @default 0xFFFFFF\n     */\n    public get tileHighlightStrokeColor(): number {\n        return this._config.tileHighlightStrokeColor;\n    }\n    public set tileHighlightStrokeColor(value: number) {\n        this._config.tileHighlightStrokeColor = value;\n    }\n    /**\n     * alpha value for the tile highlight fill (this will be overridden if a highlight-image is defined)\n     * @property\n     * @default 1.0\n     */\n    public get tileHighlightFillAlpha(): number {\n        return this._config.tileHighlightFillAlpha;\n    }\n    public set tileHighlightFillAlpha(value: number) {\n        this._config.tileHighlightFillAlpha = value;\n    }\n    /**\n     * color code for the tile highlight fill (this will be overridden if a highlight-image is defined)\n     * @property\n     * @default 0x80d7ff\n     */\n    public get tileHighlightFillColor(): number {\n        return this._config.tileHighlightFillColor;\n    }\n    public set tileHighlightFillColor(value: number) {\n        this._config.tileHighlightFillColor = value;\n    }\n}\n","let saidHello = false;\nconst VERSION = '$_VERSION';\n\n/**\n * Skips the hello message of renderers that are created after this is run.\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @function\n * @method\n * @static\n * @public\n */\nexport function skipHello(): void {\n    saidHello = true;\n}\n\n/**\n * Logs out the version information for this running instance of TRAVISO.\n * If you don't want to see this message you can run `TRAVISO.skipHello()` before\n * creating your engine.\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @function\n * @method\n * @static\n * @public\n */\nexport function sayHello(): void {\n    if (saidHello) {\n        return;\n    }\n\n    if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {\n        const args = [\n            `\\n %c %c %c Traviso.js - ${VERSION}  %c  %c  http://www.travisojs.com/  %c  \\n\\n`,\n            'background: #18bc9c; padding:5px 0;',\n            'background: #18bc9c; padding:5px 0;',\n            'color: #18bc9c; background: #030307; padding:5px 0;',\n            'background: #18bc9c; padding:5px 0;',\n            'background: #5ad2ba; padding:5px 0;',\n            'background: #18bc9c; padding:5px 0;',\n        ];\n\n        self.console.log(...args);\n    } else if (self.console) {\n        self.console.log(`Traviso.js ${VERSION} - http://www.travisojs.com/`);\n    }\n\n    saidHello = true;\n}\n","/**\n * String of the current TRAVISO version.\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @property\n * @static\n * @public\n * @constant\n */\n\nexport const VERSION: Readonly<string> = '$_VERSION';\n","import { TEngineConfiguration, EngineView } from './map/EngineView';\nimport { sayHello } from './utils/hello';\nimport { enableDisableLogging, trace } from './utils/trace';\nimport { VERSION } from './version';\n\n/**\n * Type declaration for global traviso configuration.\n */\nexport type TTravisoConfiguration = {\n    /**\n     * Determines if TRAVISO can log helper text.\n     * @default false\n     */\n    logEnabled: boolean;\n};\n\n/**\n * Main TRAVISO namespace.\n *\n * @namespace TRAVISO\n */\nexport * from './version';\nexport * from './map/EngineView';\nexport { TileView } from './map/TileView';\nexport { ObjectView } from './map/ObjectView';\nexport { skipHello } from './utils/hello';\nexport * from './utils/trace';\nexport { existy, mathMap, dotProduct, getUnit, getDist, isInPolygon } from './utils/calculations';\nexport {\n    TDirection,\n    TDirections,\n    DIRECTIONS,\n    PF_ALGORITHMS,\n    TPathFindingAlgorithms,\n    TPathFindingAlgorithmID,\n} from './utils/constants';\nexport { TColumnRowPair, TPositionPair } from './utils/map';\n\n/**\n * Global configuration settings for traviso\n *\n * @property\n * @private\n * @internal\n */\nlet config: TTravisoConfiguration = {\n    logEnabled: false,\n};\n\n/**\n * Flag defining whether traviso is set or not\n *\n * @property\n * @private\n * @internal\n */\nlet isReady: boolean = false;\n\n/**\n * Initializes traviso global settings if it hasn't been already.\n *\n * @method\n * @function\n * @internal\n *\n * @param globalConfig {TTravisoConfiguration} configuration object for the traviso engine\n */\nconst init = (globalConfig: TTravisoConfiguration): void => {\n    // do necessary checks and assignments for global settings\n    if (globalConfig) {\n        config = {\n            ...config,\n            ...globalConfig,\n        };\n        config.logEnabled = enableDisableLogging(globalConfig.logEnabled);\n    }\n    if (isReady) {\n        return;\n    }\n    isReady = true;\n    sayHello();\n    trace('Traviso initiated. (Version: ' + VERSION + ')');\n};\n\n/**\n * Creates and returns an isometric engine instance with the provided configuration.\n * Also initializes traviso global settings if it hasn't been already.\n *\n * @memberof TRAVISO\n * @for TRAVISO\n *\n * @method\n * @function\n * @public\n * @static\n *\n * @param instanceConfig {TEngineConfiguration} Configuration object for the isometric instance, required\n * @param globalConfig {TTravisoConfiguration} Configuration object for the traviso engine, default null\n *\n * @returns {EngineView} A new instance of the isometric engine\n */\nexport const getEngineInstance = (\n    instanceConfig: TEngineConfiguration,\n    globalConfig: TTravisoConfiguration = null\n): EngineView => {\n    init(globalConfig);\n    return new EngineView(instanceConfig);\n};\n\nexport {};\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","c","r","weight","x","y","mapPos","GridNode","fromNeighbor","scoreFunction","content","BinaryHeap","element","push","sinkDown","result","end","pop","bubbleUp","node","indexOf","parentN","parent_1","elemScore","conditionMet","child2N","child1N","swap","child1Score","child1","child2","mapSizeC","mapSizeR","options","nodes","diagonal","heuristic","PathFinding","HEURISTICS","manhattan","closest","grid","init","dirtyNodes","cleanNode","ret","rowDebug","row","len","l","graphString","join","originC","originR","destC","destR","start","search","cellC","cellR","sizeC","sizeR","cellArray","concat","neighbors","curr","path","parent","f","openHeap","getHeap","closestNode","h","size","currentNode","pathTo","closed","il","neighbor","isWall","gScore","g","getCost","beenVisited","visited","markDirty","rescoreElement","movable","staticWeight","pos0","pos1","Math","abs","D2","sqrt","d1","d2","min","existy","value","mathMap","v","min1","max1","min2","max2","noOutliers","getUnit","m","isInPolygon","gp","vertices","j","testY","testX","nVert","getDist","p1","p2","DIRECTIONS","O","S","SW","W","NW","N","NE","E","SE","RESERVED_TEXTURE_IDS","PF_ALGORITHMS","ASTAR_ORTHOGONAL","ASTAR_DIAGONAL","logEnabled","trace","self","console","log","enableDisableLogging","enabled","getObjectTextures","engine","objectType","visualId","objInfo","mapData","objects","textures","textureNames","Texture","from","Error","linearTween","easeInQuad","easeOutQuad","easeInOutQuad","defaultSpeed","_engine","_defaultSpeed","_processFunc","run","bind","_ticker","Ticker","add","MoveEngine","o","duration","vars","delay","easing","overwrite","onComplete","e","prop","target","Number","easingFunc","totalFrames","_fps","currentFrame","_tweenTargets","tweens","_activeForTweens","targetRemoved","idx","idx2","splice","_movables","_activeForMovables","speedUnit","speed","currentPath","currentTarget","currentPathStep","speedMagnitude","pos","px","getTilePosXFor","py","getTilePosYFor","tileHalfHeight","position","currentReachThresh","ceil","_processFrame","prevPosition","onObjMoveStepEnd","checkForTileChange","checkForFollowCharacter","tt","removeTween","stop","removeAllMovables","removeAllTweens","type","animSpeed","_super","_this","onContainerAnimComplete_delayed_binded","onContainerAnimComplete_delayed","onContainerAnimComplete_binded","onContainerAnimComplete","info","key","nt","io","rowSpan","columnSpan","getObjectInfo","isMovableTo","isInteractive","interactive","interactiveChildren","isFloorObject","noTransparency","xAnchor","_textures","_interactionOffsets","currentInteractionOffset","idle","_container","AnimatedSprite","anchor","addChild","gotoAndStop","ObjectView","animationSpeed","direction","moving","stopOnFirstFrame","noLoop","onAnimComplete","changeVisual","dir","getStationaryDirVisualId","currentDirection","vId","loop","onContainerAnimCompleteCallback","gotoAndPlay","objectUpdateCallback","setTimeout","Container","onHighlightTweenEnd_binded","onHighlightTweenEnd","halfHeight","halfWidth","tileHalfWidth","tileInfo","tileType","tiles","singleGroundImage","parseInt","getTileInfo","_tileGraphics","tileHighlightImage","_highlightedOverlay","Sprite","Graphics","clear","lineStyle","tileHighlightStrokeAlpha","tileHighlightStrokeColor","beginFill","tileHighlightFillColor","tileHighlightFillAlpha","moveTo","lineTo","endFill","scale","visible","TileView","isHighlighted","instant","_isHighlighted","ts","moveEngine","addTween","killTweensOf","config","w","onMouseUp_binded","onMouseUp","onMouseDown_binded","onMouseDown","onMouseMove_binded","onMouseMove","_config","followCharacter","changeTransparencies","highlightPath","highlightTargetTile","tileHighlightAnimated","dontAutoMoveToTile","checkPathOnEachTile","mapDraggable","isoAngle","EngineView","DEFAULT_ISO_ANGLE","tileHeight","DEFAULT_TILE_H","setZoomParameters","minScale","maxScale","numberOfZoomLevels","initialZoomLevel","instantCameraZoom","tan","PI","loadAssetsAndData","mapDataPath","split","loader","Loader","crossOrigin","assetsToLoad","load","assetsAndDataLoaded","arr","resources","data","initialControllableLocation","columnIndex","rowIndex","obj","objId","visual","interactionOffsets","oTextures","rows","groundMap","groundMapData","replace","objectsMap","objectsMapData","visuals","id","ipor","ipoc","frames","extension","numberOfFrames","startIndex","floor","onAllAssetsLoaded","_currentScale","_currentZoom","_posFrame","initialPositionFrame","_externalCenter","createMap","repositionContent","enableInteraction","engineInstanceReadyCallback","backgroundColor","_bg","useMask","_mapMask","_mapContainer","_groundContainer","_objContainer","groundImageSprite","tile","_mapSizeR","_mapSizeC","set","_tileArray","_objArray","_pathFinding","pathFindingType","pathFindingClosest","setCell","floorObjectFound","addObjRefToLocation","_currentControllable","a","k","_mapVertices","_mapVisualWidthReal","_mapVisualHeightReal","width","height","zoomTo","centralizeToLocation","centralizeToCurrentExternalCenter","show","addObjectToLocation","arrangeDepthsFromLocation","displayObject","removeChild","removeObjRefFromLocation","focusMapToLocation","zoomAmount","instantCameraRelocation","instantRelocate","_currentFocusLocation","_mapVisualWidthScaled","centralizeToPoint","minZoom","maxZoom","zoomIncrement","instantZoom","round","diff","oldScale","setScale","ratio","addObjRefToSingleLocation","setDynamicCell","removeObjRefFromSingleLocation","index","alpha","prevPos","changeObjAlphasInLocation","newPath","pathItem","setHighlighted","currentTargetTile","removeMovable","instantObjectRelocation","arrangeObjTransparencies","arrangeObjLocation","arrangePathHighlight","stopObject","prepareForMove","onObjMoveStepBegin","r1","c1","r2","c2","changeVisualToDirection","isCellFilled","checkAndMoveObjectToLocation","setMoveParameters","addMovable","pathEnded","moveObjThrough","objectReachedDestinationCallback","getObjectsAtLocation","otherObjectsOnTheNextTileCallback","to","solve","getPath","targetPos","minPath","tempFlagHolder","getAdjacentOpenCells","minLength","lp","closestTile","thresh","dist","closestDist","interactionData","toLocal","global","getTileFromLocalPos","objectSelectCallback","checkAndMoveObjectToTile","tileSelectCallback","on","off","_dragging","event","globalPos","isInteractionInMask","_dragInitStartingX","_dragPrevStartingX","_dragInitStartingY","_dragPrevStartingY","distX","distY","checkForTileClick","posFrame","centralizeToCurrentFocusLocation","drawRect","mask","item","disableInteraction","destroy","saidHello","VERSION","isReady","globalConfig","navigator","userAgent","toLowerCase","args","_a","sayHello","v1","v2","instanceConfig"],"mappings":"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"}